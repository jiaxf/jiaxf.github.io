{"meta":{"title":"飞天雪的技术博客","subtitle":"技术无止境","description":"jiaxf's blog | js | node | javascript","author":"Jiaxf","url":"http://jiaxf.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":false,"path":"/404.html","permalink":"http://jiaxf.github.io//404.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt;"},{"title":"Home","date":"2016-12-01T03:56:23.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"Home/index.html","permalink":"http://jiaxf.github.io/Home/index.html","excerpt":"","text":"首页"},{"title":"categories","date":"2018-04-13T07:52:02.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://jiaxf.github.io/categories/index.html","excerpt":"","text":"layout: categoriescomments: false"},{"title":"about","date":"2016-12-01T03:56:41.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"about/index.html","permalink":"http://jiaxf.github.io/about/index.html","excerpt":"","text":"关于我 西北农林科技大学，02级木材科学与工程、计算机科学与技术(本科双学士) 北京林业大学，09级计算机软件与理论(硕士) 热爱互联网，算法 从事Web前后端工作 【技能】 语言：Javascript; nodejs; java; Shell 工具：eclipse; Linux; Vim; tomcat; Apache; 【校园经历】2002.9- 2006.7 西北农林科技大学优秀学生干部、优秀团员 【实习经历】2006.9-2007.9 中国国情与发展研究所 助理研究员2009.5-2010.3 中国互联网络信息中心cnnic：无线网址组 【工作经历】2010.5-2011.5 数字政通科技股份有限公司：数字城管事业部 开发二组 软件开发工程师2011.5-今 外语教学与研究出版社：研发中心 技术部 高级软件开发工程师 【工作内容】 项目时间：2011.5 – 今 项目名称：外研社研发中心技术部相关项目开发 项目描述： 外研社语言技术部主要从事语言技术相关的项目，包括词典数据的XML结构化、大规模语料库系统的建设和检索，词典结构化数据的一些衍生产品&gt;的研发如基于结构化xml词典数据的在线词典开发，词典词表数据比较、句子语法分析、汉语拼音标准、词典数据排序等以及词典编纂平台的设计开发等。 项目职责与任务： 独立完成了《现代英汉词典第3版》、《精编德汉汉德词典》、《德汉汉德留学词典》、《外研社现代汉德词典（第二版）》等10余部词典的xml结构化解析； Kindle Mobi电子书的制作：双语平台英汉对照的电子表格Excel文件进行处理，java程序读取excel表格文件，处理成符合kindle电子书要求的mobi电子书150余本；少儿分社萤火虫系列图文版以及其他一些畅销书电子书20余本； 基于xml格式数据的在线词典开发，针对外研社不同语种的词典xml数据，设计开发了支持多语种查询的在线词典系统供社内词典相关业务编辑使用，系统采用bootstrap＋ javascript＋jsp＋Servlet实现，主要负责了前台界面的开发和后台部分servlet的实现； 开发设计一些编辑工作过程中的小工具如汉字字典排序、词典词表比较系统等； 使用nodejs搭建开发环境，使用node-webkit ＋ javscript＋http service实现跨平台系统，初步完成词典编纂系统的开发，目前系统还在进一步开发中； 项目时间：2010.5 – 2011.5 项目名称：北京数字政通科技股份有限公司 项目描述： 北京数字政通科技股份有限公司专业从事电子政务和GIS应用平台的开发和推广工作，为政府部门提供GIS、MIS、OA一体化的电子政务解决方案，&gt;并提供政府各个部门间基于数据共享的协同工作平台。所在的数字城管事业部从事数字城市、数字社区的解决方案服务和项目开发，在标准流程城管系统基础上根据当地实际需求进行相应的二次功能开发，后期维护相应的系统。数字城管系统客户端是采用YUI框架的jsp和javscript技术实&gt;现的web应用程序，服务器端是spring+struts2+oracle+金蝶中间服务 件实现 项目职责及任务: 参与了数字社区V2.0项目的封闭式开发，完成了社区街道管理模块的相应开发； 参加了安徽铜陵市铜官山区城管系统的二次开发和根据当地实际需求的功能开发； 参与完成了河南开封市数字城管系统考评系统的开发任务； 数字城管系统华北项目的bug维护工作，根据测试人员的反馈，对系统使用中出现的bug进行修复和零散小的需求功能点的开发； 项目时间：2009.5 – 2010.3 项目名称：中国互联网络信息中心（CNNIC）无线网址组SP系统及掌中锦囊（wap.cn）系 统的部分开发&lt;团队开发&gt; 项目描述： 无线网址组SP系统是为CNNIC无线网址事业部内部使用的收费管理系统，掌中锦囊（wap.cn）是无线网址组无线业务的服务网站,都属于CNNIC无线网址组的核心业务部分。 项目职责与任务： 在中国互联网络信息中心无线网址组实习阶段，负责了SP系统的数据层的单元测试（白盒测试），参与了掌中锦囊（wap.cn）中几个功能模块的实现，负责比价查询、邮编区号、股票查询、外汇查询、邮编区号及火车时刻表查询模块的功能实现,其中比价查询是和比价网数据接口合作，通&gt;过解析比价网提供的xml数据建立本地的oracle数据库进行查询，邮编区号、火车时刻表查询都是通过本地建立oracle数据库进行查询，股票、外&gt;汇查询是采用WebService接口查询实现。 【获奖】 外研社2012财年年度优秀员工 外研社2014财年年度优秀员工 外研社2015财年年度优秀员工 【爱好】读书 足球 羽毛球 旅游 【联系我】 Email : jiaxuefeng0@gmail.com 新浪微博 ：@飞天雪峰 github ：@jiaxf LinkdeIn :xuefeng jia"},{"title":"readings","date":"2016-12-01T03:56:06.000Z","updated":"2018-04-25T07:37:06.000Z","comments":true,"path":"readings/index.html","permalink":"http://jiaxf.github.io/readings/index.html","excerpt":"","text":"Reading List索引 文学 传记 历史 科学 技术 文学 《我不是潘金莲》by 刘震云 （在读） 《生命不息，奋斗不止》 by 罗永浩（读完） 《解忧杂货店》by 东野圭吾 （读完） 《三体》by 刘慈欣 （在读） 《白说》by 白岩松 （读完） 传记 乔布斯传 （读完） 历史 《大秦帝国》 （在读） 《琅琊榜》(在读) 科学 1. 技术 《编程之美》 （在读）"},{"title":"tags","date":"2018-04-13T07:51:37.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://jiaxf.github.io/tags/index.html","excerpt":"","text":"layout: tagscomments: false"},{"title":"search","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"search/index.html","permalink":"http://jiaxf.github.io/search/index.html","excerpt":"","text":"正在加载搜索结果，请稍等。 .st-result-text { background: #fafafa; display: block; border-left: 0.5em solid #ccc; -webkit-transition: border-left 0.45s; -moz-transition: border-left 0.45s; -o-transition: border-left 0.45s; -ms-transition: border-left 0.45s; transition: border-left 0.45s; padding: 0.5em;}@media only screen and (min-width: 768px) { .st-result-text { padding: 1em; }}.st-result-text:hover { border-left: 0.5em solid #ea6753;}.st-result-text h3 a{ color: #2ca6cb; line-height: 1.5; font-size: 22px;}.st-snippet em { font-weight: bold; color: #ea6753;} &lt;!–注意下面到结束的代码块要替换成自己上面保存的Install Code代码–!&gt; (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install','f9SxgsuoT3T5zTyGctUR','2.0.0');"},{"title":"","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"works/data.js","permalink":"http://jiaxf.github.io/works/data.js","excerpt":"","text":"var data = { \"main\": [{ \"id\": \"community\", \"title\": \"圈子\", \"list\": [{ \"tab\": \"视频教程\", \"item\": [{ \"name\": \"慕课网\", \"href\": \"http://www.imooc.com/\", \"title\": \"慕课网是一个IT视频网站\" }, { \"name\": \"极客学院\", \"href\": \"http://www.jikexueyuan.com/\", \"title\": \"\" }] }, { \"tab\": \"前端知识\", \"item\": [{ \"name\": \"菜鸟教程\", \"href\": \"http://www.runoob.com/\", \"title\": \"\" }, { \"name\": \"w3school\", \"href\": \"http://www.w3school.com.cn/\", \"title\": \"\" }] }] }, { \"id\": \"html\", \"title\": \"CSS/HTML\", \"list\": [{ \"tab\": \"CSS\", \"item\": [{ \"name\": \"CSS3参考手册\", \"href\": \"http://css.doyoe.com/\", \"title\": \"\" }, { \"name\": \"浏览器Hack大全\", \"href\": \"http://browserhacks.com/\", \"title\": \"\" }, { \"name\": \"ie默认css\", \"href\": \"http://www.iecss.com/\", \"title\": \"\" }, { \"name\": \"Animate动画库\", \"href\": \"http://daneden.github.io/animate.css/\", \"title\": \"\" }] }, { \"tab\": \"HTML\", \"item\": [{ \"name\": \"HTML5中国\", \"href\": \"http://www.html5cn.org/\", \"title\": \"\" }, { \"name\": \"HTML5基地\", \"href\": \"http://html5.360.cn/\", \"title\": \"\" }, { \"name\": \"5+App\", \"href\": \"http://ask.dcloud.net.cn/explore/\", \"title\": \"\" }] }] }, { \"id\": \"blog\", \"title\": \"博客社区\", \"list\": [{ \"tab\": \"社区\", \"item\": [{ \"name\": \"Github\", \"href\": \"https://github.com/\", \"title\": \"\" }, { \"name\": \"SegmentFault\", \"href\": \"https://segmentfault.com/\", \"title\": \"\" }, { \"name\": \"W3Cfuns\", \"href\": \"http://www.w3cfuns.com/\", \"title\": \"\" }, { \"name\": \"CSDN\", \"href\": \"http://blog.csdn.net/web/index.html\", \"title\": \"\" }, { \"name\": \"博客园\", \"href\": \"http://www.cnblogs.com/\", \"title\": \"\" }, { \"name\": \"伯乐在线\", \"href\": \"http://web.jobbole.com/\", \"title\": \"\" }, { \"name\": \"开源中国\", \"href\": \"http://www.oschina.net/\", \"title\": \"\" }] }, { \"tab\": \"博客\", \"item\": [{ \"name\": \"阮一峰\", \"href\": \"http://www.ruanyifeng.com/home.html\", \"title\": \"\" }] }] }, { \"id\": \"js\", \"title\": \"JavaScript\", \"list\": [{ \"tab\": \"原生开发\", \"item\": [{ \"name\": \"MDN(JavaScript)\", \"href\": \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\", \"title\": \"\" }, { \"name\": \"JavaScript 秘密花园\", \"href\": \"http://bonsaiden.github.io/JavaScript-Garden/zh/\", \"title\": \"\" }, { \"name\": \"JavaScript资源大全\", \"href\": \"https://github.com/jobbole/awesome-javascript-cn\", \"title\": \"\" }] }, { \"tab\": \"JavaScript库\", \"item\": [{ \"name\": \"JQuery\", \"href\": \"http://jquery.com/\", \"title\": \"\" }, { \"name\": \"Zepto\", \"href\": \"http://www.css88.com/doc/zeptojs_api/#ajax\", \"title\": \"\" }, { \"name\": \"AngularJS\", \"href\": \"https://angularjs.org/\", \"title\": \"\" }, { \"name\": \"KISSY\", \"href\": \"http://docs.kissyui.com/\", \"title\": \"\" }, { \"name\": \"ExtJS\", \"href\": \"http://extjs.org.cn/\", \"title\": \"\" }] }, { \"tab\": \"JQuery\", \"item\": [{ \"name\": \"jQuery中文文档\", \"href\": \"http://www.jquery123.com/\", \"title\": \"\" }, { \"name\": \"JQuery插件库\", \"href\": \"http://www.jq22.com/\", \"title\": \"\" }, { \"name\": \"JQuery之家\", \"href\": \"http://www.htmleaf.com/\", \"title\": \"\" }, { \"name\": \"jQuery Transit 动画库\", \"href\": \"http://www.htmleaf.com/jQuery/Layout-Interface/201501281289.html\", \"title\": \"\" }, { \"name\": \"JQueryFuns\", \"href\": \"http://www.jqueryfuns.com/\", \"title\": \"\" }, { \"name\": \"FullPage.js\", \"href\": \"http://www.dowebok.com/77.html\", \"title\": \"\" }, { \"name\": \"富文本编辑器\", \"href\": \"http://www.biaodianfu.com/editor.html\", \"title\": \"\" }] }] }, { \"id\": \"mobile\", \"title\": \"移动端/响应式\", \"list\": [{ \"tab\": \"移动端\", \"item\": [{ \"name\": \"Ionic\", \"href\": \"http://www.ionic.wang/\", \"title\": \"\" }, { \"name\": \"JQueryMobile\", \"href\": \"http://jquerymobile.com/\", \"title\": \"\" }, { \"name\": \"5+App\", \"href\": \"http://www.dcloud.io/docs/api/index.shtml\", \"title\": \"\" }, { \"name\":\"Framework7\", \"href\":\"http://framework7.io/\", \"title\":\"\" },{ \"name\": \"FrozenUI\", \"href\": \"http://frozenui.github.io/\", \"title\": \"\" }, { \"name\": \"Mobile Angular UI\", \"href\": \"http://mobileangularui.com/\", \"title\": \"\" }] }, { \"tab\": \"响应式\", \"item\": [{ \"name\": \"Bootstrap\", \"href\": \"http://www.bootcss.com/\", \"title\": \"\" }, { \"name\": \"Material-UI\", \"href\": \"http://www.material-ui.com/#/\", \"title\": \"\" }, { \"name\": \"UIkit\", \"href\": \"http://getuikit.com/\", \"title\": \"\" }, { \"name\": \"AmazeUI\", \"href\": \"http://amazeui.org/\", \"title\": \"\" }] }, { \"tab\": \"模块化\", \"item\": [{ \"name\": \"CommonJS\", \"href\": \"http://www.commonjs.org/\", \"title\": \"\" }, { \"name\": \"Sea.js\", \"href\": \"http://seajs.org/docs/\", \"title\": \"\" }, { \"name\": \"RequireJS\", \"href\": \"http://requirejs.org/\", \"title\": \"\" }, { \"name\": \"NodeJS\", \"href\": \"https://nodejs.org/en/\", \"title\": \"\" }] }] }, { \"id\": \"tool\", \"title\": \"实用工具\", \"list\": [{ \"tab\": \"CSS\", \"item\": [{ \"name\": \"css3动画工具\", \"href\": \"http://isux.tencent.com/css3/tools.html\", \"title\": \"\" }] }, { \"tab\": \"编辑器\", \"item\": [{ \"name\": \"Sublime Text\", \"href\": \"http://www.sublimetext.com/\", \"title\": \"\" }, { \"name\": \"HBuilder\", \"href\": \"http://www.dcloud.io/\", \"title\": \"\" }, { \"name\": \"Atom\", \"href\": \"https://atom.io/\", \"title\": \"\" }, { \"name\": \"WebStorm\", \"href\": \"https://www.jetbrains.com/webstorm/\", \"title\": \"\" }, { \"name\": \"Dreamweaver\", \"href\": \"http://www.adobe.com/cn/products/dreamweaver.html\", \"title\": \"\" }] }, { \"tab\": \"在线编辑器\", \"item\": [{ \"name\": \"RunJS\", \"href\": \"http://runjs.cn/\", \"title\": \"在线编辑、展示、分享、交流你的 JavaScript 代码\" }, { \"name\": \"Online IDE\", \"href\": \"http://www.compileonline.com/\", \"title\": \"\" }, { \"name\": \"CODEPEN\", \"href\": \"http://codepen.io/\", \"title\": \"\" }, { \"name\": \"JS Bin\", \"href\": \"http://jsbin.com/?html,output\", \"title\": \"\" }, { \"name\": \"CSSdeck\", \"href\": \"http://cssdeck.com/\", \"title\": \"\" }] }, { \"tab\": \"格式化\", \"item\": [{ \"name\": \"Tool 在线工具\", \"href\": \"http://tool.lu/\", \"title\": \"\" }, { \"name\": \"站长工具\", \"href\": \"http://tool.chinaz.com/tools/jscodeconfusion.aspx\", \"title\": \"\" }, { \"name\": \"C在线工具\", \"href\": \"http://tool.oschina.net/\", \"title\": \"\" }, { \"name\": \"Less 编译\", \"href\": \"http://tool.oschina.net/less\", \"title\": \"\" },{ \"name\": \"图好快\", \"href\": \"http://www.tuhaokuai.com/\", \"title\": \"无需下载安装，一个让图片压缩更简单的在线工具！\" }] }] }, { \"id\": \"source\", \"title\": \"文档/资源库\", \"list\": [{ \"tab\": \"前端文档\", \"item\": [{ \"name\": \"HTML\", \"href\": \"http://www.runoob.com/tags/html-reference.html\", \"title\": \"\" }, { \"name\": \"CSS\", \"href\": \"http://www.runoob.com/cssref/css-reference.html\", \"title\": \"\" }, { \"name\": \"JavaScript\", \"href\": \"http://www.runoob.com/js/js-tutorial.html\", \"title\": \"\" },{ \"name\": \"JavaScript标准参考教程\", \"href\": \"http://javascript.ruanyifeng.com/\", \"title\": \"\" }, { \"name\": \"HTML5\", \"href\": \"https://www.w3.org/html/ig/zh/wiki/HTML5\", \"title\": \"\" }, { \"name\": \"CSS3\", \"href\": \"http://www.divcss5.com/css3/\", \"title\": \"\" }, { \"name\": \"JQuery\", \"href\": \"http://jquery.cuishifeng.cn/\", \"title\": \"\" }, { \"name\": \"AngularJS\", \"href\": \"http://www.apjs.net/\", \"title\": \"\" }, { \"name\": \"NodeJS\", \"href\": \"http://nodeapi.ucdok.com/\", \"title\": \"\" }, { \"name\": \"5+App\", \"href\": \"http://www.html5plus.org/doc/h5p.html\", \"title\": \"\" }] }, { \"tab\": \"静态资源库\", \"item\": [{ \"name\": \"百度静态资源共享库\", \"href\": \"http://cdn.code.baidu.com/\", \"title\": \"\" }, { \"name\": \"BootCDN\", \"href\": \"http://www.bootcdn.cn/\", \"title\": \"\" }] }, { \"tab\": \"电子书\", \"item\": [{ \"name\": \"看云\", \"href\": \"http://www.kancloud.cn/\", \"title\": \"\" }, { \"name\": \"爱思源\", \"href\": \"http://www.aseoe.com/webook/\", \"title\": \"\" }, { \"name\": \"脚本之家\", \"href\": \"http://www.jb51.net/books/\", \"title\": \"\" }] }] }, { \"id\": \"ui\", \"title\": \"UI设计\", \"list\": [{ \"tab\": \"图标库\", \"item\": [{ \"name\": \"Font Asesome\", \"href\": \"http://fontawesome.io/icons/\", \"title\": \"\" }, { \"name\": \"阿里矢量图\", \"href\": \"http://www.iconfont.cn/\", \"title\": \"\" },{ \"name\":\"ionicons\", \"href\":\"http://ionicons.com/\", \"title\":\"\" }, { \"name\": \"iconmoon\", \"href\": \"https://icomoon.io/\", \"title\": \"\" }, { \"name\": \"iconfinder\", \"href\": \"https://www.iconfinder.com/\", \"title\": \"\" }] }, { \"tab\": \"素材下载\", \"item\": [{ \"name\": \"千图网\", \"href\": \"http://www.58pic.com/\", \"title\": \"\" }, { \"name\": \"17素材\", \"href\": \"http://www.17sucai.com/\", \"title\": \"\" }, { \"name\": \"站长素材\", \"href\": \"http://sc.chinaz.com/\", \"title\": \"\" }, { \"name\": \"懒人之家\", \"href\": \"http://www.lanrenzhijia.com/\", \"title\": \"\" },{ \"name\":\"6m5m\", \"href\":\"http://www.6m5m.com/\", \"title\":\"游戏素材资源平台\" }] },{ \"tab\": \"思维导图\", \"item\": [{ \"name\": \"processon\", \"href\": \"http://www.processon.com/\", \"title\": \"ProcessOn是一个方便易用、免费高效的在线作图工具\" }] }] }] };"},{"title":"","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"works/index.html","permalink":"http://jiaxf.github.io/works/index.html","excerpt":"","text":"TG-网址导航 前端网址集锦 欢迎来到前端网址导航，本站收集了一些常用优秀的网址.（摘自铁锅博客的网址导航）"},{"title":"","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"works/navigation.css","permalink":"http://jiaxf.github.io/works/navigation.css","excerpt":"","text":"html { font-size: 62.5%; } body { font: 1.4rem/1.5 Helvetica Neue, Helvetica, Arial, PingFang SC, Hiragino Sans GB, WenQuanYi Micro Hei, Microsoft Yahei, sans-serif; color: #555; overflow-x: hidden; } body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch; } html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 { -webkit-text-size-adjust: none; } * { margin: 0; padding: 0; box-sizing: border-box; -webkit-box-sizing: border-box; } /* Scrollbar */ ::-webkit-scrollbar { width: 10px; height: 10px; } ::-webkit-scrollbar-track, ::-webkit-scrollbar-thumb { border-right: 1px solid transparent; border-left: 1px solid transparent; } ::-webkit-scrollbar-button:start { width: 10px; width: 9px; height: 12px; background: transparent url(/images/arrow.png) no-repeat 0 0; } ::-webkit-scrollbar-button:end { width: 10px; width: 9px; height: 12px; background: transparent url(/Public/images/arrow.png) no-repeat -50px 0; } ::-webkit-scrollbar-thumb { -webkit-border-radius: 8px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.2); } ::-webkit-scrollbar-corner { display: block; } ::-webkit-scrollbar-track:hover { background-color: rgba(0, 0, 0, 0.15); } ::-webkit-scrollbar-thumb:hover { -webkit-border-radius: 8px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.5); } .nav-navbar { height: 45px; line-height: 45px; width: 100%; background-color: #009a61; color: #fff; box-shadow: 0 3px 5px #999; text-align: center; font-size: 3rem; } .nav-navbar a { text-decoration: none; color: #fff; } .grumble { position: absolute; top: 50px; left: 50%; max-width:250px; border-radius: 5px; line-height: 20px; padding: 10px; background: rgba(0, 0, 0, .8); color:#fff; transform: translateX(-50%); z-index: 1; } .grumble::before { content: \"\"; position: absolute; left: 50%; bottom: -20px; transform: translateX(-50%); border-top: 10px solid rgba(0, 0, 0, .8); border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid transparent; } .nav-notice { margin: 15px; height: 35px; line-height: 35px; padding: 0 10px; color: #333; background: #fff; box-shadow: 0 0 5px #999; -webkit-box-shadow: 0 0 5px #999; } .nav-container { position: relative; margin: 15px; } .nav-aside { position: fixed; left: 350px; top: 200px; width: 150px; background-color: #009a61; box-shadow: 0 0 5px #999; -webkit-box-shadow: 0 0 5px #999; transition: all .5s; -webkit-transition: all .5s; } .nav-content { margin-left: 150px; } .nav-aside>ul>li { list-style: none; height: 30px; line-height: 30px; color: #fff; text-align: center; cursor: pointer; } .nav-aside>ul>li a { color: #fff; text-decoration: none; } .nav-list { padding: 5px 20px; margin: 15px 0; background-color: #fff; box-shadow: 0 0 5px #999; -webkit-box-shadow: 0 0 5px #999; } .nav-list-title { height: 40px; line-height: 40px; font-size: 1.6rem; font-weight: normal; border-bottom: 1px solid #d9d9d9; } .nav-list-main { padding: 10px 0; } .nav-classify { display: flex; display: -webkit-flex; flex-wrap: wrap; -webkit-flex-wrap: wrap; } .nav-classify-tab { height: 40px; width: 100px; line-height: 40px; text-align: center; color: #fff; background-color: #2a2a2a; } .nav-classify-content { position: relative; width: -webkit-calc(100% - 100px); width: calc(100% - 100px); display: flex; display: -webkit-flex; flex-wrap: wrap; -webkit-flex-wrap: wrap; } .nav-classify-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; } .nav-classify-bg .line { width: 0; height: 100%; background: #eee; margin: 0 auto; transition: all .5s; -webkit-transition: all .5s; } .nav-classify-content.active .nav-classify-bg .line { width: 100%; } .nav-classify-item { position: relative; height: 40px; line-height: 40px; cursor: pointer; z-index: 1; } /*.nav-classify-item:hover:before{ content:attr(data-intro); position:absolute; top:0; left:0; min-width:100%; text-align: center; color:#fff; background:rgba(0,0,0,.7); border-radius:5px; font-size:13px; -webkit-transform:translate(0,-webkit-calc(-100% - 10px)); transform:translate(0,calc(-100% - 10px)); } .nav-classify-item:hover:after{ content:''; position:absolute; top:-10px; left:50%; border:10px solid transparent; border-top:10px solid rgba(0,0,0,.7); -webkit-transform:translate(-50%,0); transform:translate(-50%,0); }*/ .nav-classify-item:hover { background: #3f3f3f; } .nav-classify-item:hover a { color: #fff; } .nav-classify-item a { display:block; text-decoration: none; color: #333; height:40px; padding: 0 20px; }"},{"title":"","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"works/util.js","permalink":"http://jiaxf.github.io/works/util.js","excerpt":"","text":"var utils = {}; utils.navigation = { init: function() { utils.navigation.create(); utils.navigation.pageEvent(); utils.navigation.clickTab(); utils.navigation.hover(); }, create: function() { var main = data.main; var tab = \"\"; $.each(main, function(k, v) { var list = v.list; tab += '' + v.title + ''; var section = ''; section += '' + v.title + ''; $.each(list, function(key, classify) { var item = classify.item; section += ''; section += ''; section += '' + classify.tab + ''; section += ''; $.each(item, function(ik, iv) { section += '' + iv.name + ''; }); section += ''; section += ''; }); section += ''; $(\".nav-content\").append(section); }); $(\".nav-aside ul\").append(tab); }, pageEvent: function() { $(document).on(\"mouseover\", \".nav-classify-content\", function(e) { $(this).addClass(\"active\"); e.stopPropagation(); }).on(\"mouseout\", \".nav-classify-content\", function(e) { $(this).removeClass(\"active\"); e.stopPropagation(); }); $(window).on(\"scroll\", function() { var wTop = $(this).scrollTop(); var nTop = 110; if (wTop >= nTop) { $(\".nav-aside\").css({ \"top\": \"0px\" }); } else { $(\".nav-aside\").css({ \"top\": nTop + \"px\" }); }; }); }, clickTab: function() { var tab = $(\".nav-aside>ul>li\"); var section = $(\".nav-list\"); var wHeight = window.innerHeight; $(document).on(\"click\", \".nav-aside>ul>li\", function() { var index = $(this).index(); var sTop = section.eq(index).offset().top; $(\"body,html\").animate({ scrollTop: sTop + \"px\" }, 1000); }); }, hover: function() { $(document).on(\"mouseover\", \".nav-classify-item\", function(e) { var intro = $(this).attr(\"data-intro\"); var top = $(this).offset().top - $(this).height() - 10; var left = $(this).offset().left + $(this).innerWidth() / 2; if (intro != \"\") { var grumble = '' + intro + ''; $(\"body\").append(grumble); }; e.stopPropagation(); }).on(\"mouseout\", \".nav-classify-item\", function(e) { $(\".grumble\").remove(); e.stopPropagation(); }); } }; $(function() { utils.navigation.init(); });"},{"title":"","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"works/data3.js","permalink":"http://jiaxf.github.io/works/data3.js","excerpt":"","text":"/* * @Author: luuman * @Last Modified by: luuman * @Date: 2016-03-09 13:13:56 * @Last Modified time: 2016-04-07 14:29:18 * @Function: Data FrontEndGuide \"Name\":\"name\" \"Title\":\"title\" \"Href\":\"htttp:\" \"New\":\"new\",\"New\":\"1\" {'Name':'','Title':'','Href':''}, {'Name':'','Title':'','Href':'',\"New\":\"1\"}, */ var FrontGuide = { \"main\":[{ \"pageT1\":\"圈子\", \"pageC1\":[{ \"pageT2\":\"前端教程\", \"pageC2\":[ {'Name':'慕课网','Title':'在线视频教程，在线代码练习','Href':'http://www.imooc.com/',\"New\":\"1\"}, {'Name':'极客学院','Title':'在线视频教学，强大的知识体系','Href':'http://www.jikexueyuan.com/'}, {'Name':'teamtree','Title':'改变你的事业。改变你的生活。','Href':'https://teamtreehouse.com/'}, {'Name':'Codecademy','Title':'Codecademy是最简单的方式来学习如何编码。这是互动的，有趣的，你可以做它与你的朋友','Href':'https://www.codecademy.com/learn',\"New\":\"1\"}, {'Name':'萌码','Title':'在线编程学习，实时问答，交互学习','Href':'http://www.mengma.com/'}, {'Name':'实验楼','Title':'第一家以实验为核心的IT在线教育平台','Href':'https://www.shiyanlou.com/'}, {'Name':'墨鱼前端','Title':'前端开发培训的公司','Href':'http://moyu-edu.com/'}, ] },{ \"pageT2\":\"前端知识\", \"pageC2\":[ {'Name':'w3cschool','Title':'万维网联盟创建于1994年，是WEB技术领域最具权威和影响力的国际中立性技术标准机构','Href':'http://www.w3school.com.cn/'}, {'Name':'菜鸟教程','Title':'学的不仅是技术，更是梦想！','Href':'http://www.runoob.com/'}, {'Name':'前端江湖','Title':'','Href':'http://www.qdjhu.com/sitemap3.html'}, {'Name':'Mozilla','Title':'Mozilla 开发者网络','Href':'https://developer.mozilla.org/zh-CN/'}, {'Name':'W3Help','Title':'系统的介绍某些知识点，帮助开发者正确理解该知识点的概念及与其他知识点的关联性，梳理知识体系。','Href':'http://www.w3help.org/zh-cn/kb/'}, {'Name':'看云','Title':'','Href':'http://www.kancloud.cn/'}, {'Name':'JS前端开发群月报','Title':'平日学习接触过的网站积累，以每月的形式发放','Href':'http://www.kancloud.cn/jsfront/month/82796/'}, {'Name':'前端开发规范手册','Title':'此手册主要实现的目标：代码一致性和最佳实践。通过代码风格的一致性，降低维护代码的成本以及改善多人协作的效率。同时遵守最佳实践，确保页面性能得到最佳优化和高效的代码。','Href':'http://zhibimo.com/read/Ashu/front-end-style-guide/index.html'}, {'Name':'Developer进阶书单','Title':'我深知自己的知识有限，所以写下本文以便和大家切磋交流。欢迎通过 GitHub 的Issues或者直接Pull Requests方式来分享你的经验。','Href':'http://phodal.github.io/booktree/#frontend'}, {'Name':'设计派导航','Title':'','Href':'http://hao.shejipai.cn/'}, {'Name':'前端人的俱乐部','Title':'做专业的前端平台，提供你需要的东西解放你的收藏夹，让它们只做最主要的事情','Href':'http://f2er.club/'}, {'Name':'觉唯','Title':'','Href':'http://www.jiawin.com/'}, ] },{ \"pageT2\":\"前端社区\", \"pageC2\":[ {'Name':'GitHub','Title':'','Href':'https://github.com/'}, {'Name':'stackoverflow','Title':'一个专业和热情的程序员','Href':'http://stackoverflow.com/'}, {'Name':'segmentfault','Title':'专注于程序员开发者的社区平台，提供开发相关的高质量问答，专栏，笔记，招聘，线下活动等服务。','Href':'http://segmentfault.com/'}, {'Name':'知乎','Title':'','Href':'http://www.zhihu.com/topics'}, {'Name':'豆瓣','Title':'','Href':'http://www.douban.com/'}, {'Name':'DCloud问答','Title':'','Href':'http://ask.dcloud.net.cn/explore/'}, {'Name':'F2E社区','Title':'','Href':'http://f2e.im/'}, {'Name':'博客园','Title':'','Href':'http://www.cnblogs.com/'}, {'Name':'前端乱炖','Title':'','Href':'http://www.html-js.com/'}, {'Name':'大前端','Title':'','Href':'http://www.daqianduan.com/'}, {'Name':'轩枫阁','Title':'','Href':'http://www.xuanfengge.com/'}, {'Name':'前端笔记','Title':'为你提供最专业的前端笔记和前端资源','Href':'http://www.w3cmark.com/'}, {'Name':'Web开发分享','Title':'','Href':'http://www.kuaipao8.com/'}, {'Name':'CSDN','Title':'','Href':'http://blog.csdn.net/web/index.html'}, {'Name':'W3Cfuns','Title':'','Href':'http://www.w3cfuns.com/'}, {'Name':'w3ctech','Title':'','Href':'http://www.w3ctech.com/'}, {'Name':'W3Cplus','Title':'','Href':'http://www.w3cplus.com/'}, {'Name':'爱编程','Title':'','Href':'http://www.w2bc.com/web'}, {'Name':'w3cfuns','Title':'','Href':'http://www.w3cfuns.com/'}, {'Name':'WEB骇客','Title':'HTML5, CSS3, WEB前端开发技术','Href':'http://www.webhek.com/'}, {'Name':'开源中国','Title':'','Href':'http://www.oschina.net/'}, {'Name':'前端观察','Title':'专注于网站前端设计与开发','Href':'http://www.qianduan.net/'}, {'Name':'ITeYe','Title':'','Href':'http://www.iteye.com/blogs/category/web'}, {'Name':'伯乐在线','Title':'','Href':'http://web.jobbole.com/'}, {'Name':'Tutorialzine','Title':'','Href':'http://tutorialzine.com/'}, {'Name':'CSSwang','Title':'','Href':'http://www.csswang.com/'}, {'Name':'Codrops','Title':'','Href':'http://tympanus.net/codrops/'}, {'Name':'牛客网','Title':'','Href':'http://www.nowcoder.com/'}, {'Name':'布布扣','Title':'','Href':'http://bubuko.com/'}, {'Name':'牛客网','Title':'','Href':'http://www.nowcoder.com/'}, {'Name':'一个','Title':'','Href':'http://www.wufafuwu.com/'}, {'Name':'Baidu前端技术学院','Title':'','Href':'http://ife.baidu.com/task/all'}, {'Name':'前端周刊','Title':'聚焦最新前端技术、框架、教程、工具、资讯和文章','Href':'http://www.feweekly.com/'}, {'Name':'可能吧','Title':'多人供稿的分享计算机技巧，关于互联网、搜索引擎，趣味信息以及心情随笔的原创博客。','Href':'https://kenengba.com/'}, ] },{ \"pageT2\":\"阿里UED\", \"pageC2\":[ {'Name':'淘宝UED','Title':'TaoBaoUED | 做地球上最好的 UED','Href':'http://ued.taobao.org/blog/'}, {'Name':'阿里巴巴(中文站 )UED','Title':'用户体验设计部博客U一点设计','Href':'http://www.aliued.cn/'}, {'Name':'阿里巴巴(国际站)UED','Title':'我们的每一次思索和设计，争论和坚持，都为追寻一个目的：在更新的屏幕里创造出更好的产品和更优的体验。','Href':'http://www.aliued.com/'}, {'Name':'阿里妈妈UED','Title':'','Href':'http://ued.alimama.com/'}, {'Name':'支付宝UED','Title':'','Href':'http://ued.alipay.com/'}, {'Name':'支付宝PED','Title':'','Href':'http://ped.alipay.com/'}, {'Name':'天猫UED','Title':'','Href':'http://ued.tmall.com/'}, {'Name':'天猫SED','Title':'','Href':'http://sed.tmall.com/'}, {'Name':'一淘UED','Title':'','Href':'http://mux.alimama.com/'}, {'Name':'AMUI','Title':'关于无线Web解决方案 - AM','Href':'http://am-team.github.io/default.html'}, ] },{ \"pageT2\":\"百度UED\", \"pageC2\":[ {'Name':'百度UED','Title':'百度联盟用户体验中心','Href':'http://ued.baidu.com/'}, {'Name':'百度FEX','Title':'','Href':'http://fex.baidu.com/'}, {'Name':'百度EFE','Title':'','Href':'http://efe.baidu.com/'}, {'Name':'百度MUX','Title':'','Href':'http://mux.baidu.com/'}, {'Name':'百度FIS','Title':'','Href':'http://fis.baidu.com/'}, ] },{ \"pageT2\":\"腾讯UED\", \"pageC2\":[ {'Name':'腾讯CDC','Title':'','Href':'http://cdc.tencent.com/'}, {'Name':'腾讯WSD','Title':'','Href':'http://wsd.tencent.com/'}, {'Name':'腾讯ISUX','Title':'','Href':'http://isux.tencent.com/'}, {'Name':'财付通TID','Title':'让生活支付更完美','Href':'http://tid.tenpay.com/'}, {'Name':'alloyteam','Title':'成为地球卓越的Web团队！','Href':'http://www.alloyteam.com/'}, {'Name':'腾讯无线MXD','Title':'','Href':'http://mxd.tencent.com/'}, {'Name':'腾讯TGideas','Title':'','Href':'http://tgideas.qq.com/'}, ] },{ \"pageT2\":\"新浪UED\", \"pageC2\":[ {'Name':'新浪UED','Title':'','Href':'http://ued.sina.com/'}, {'Name':'微博UDC','Title':'','Href':'http://udc.weibo.com/'}, {'Name':'新浪乐居UED','Title':'','Href':'http://ued.leju.com'}, ] },{ \"pageT2\":\"搜狐UED\", \"pageC2\":[ {'Name':'搜狐畅游UED','Title':'','Href':'http://vc.changyou.com/'}, {\"Name\":\"name\",\"Title\":\"title\",\"Href\":\"htttp:\"}, ] },{ \"pageT2\":\"其他UED\", \"pageC2\":[ {'Name':'网易NEC','Title':'更好的CSS解决方案','Href':'http://nec.netease.com/'}, {'Name':'网易NEJ','Title':'更好的JS解决方案','Href':'http://nej.netease.com/'}, {'Name':'网易UED','Title':'','Href':'http://ucd.blog.163.com/'}, {'Name':'去哪儿UED','Title':'','Href':'http://ued.qunar.com/'}, {'Name':'携程UED','Title':'携程旅行前端开发团队携程UED，这是一个血液中流淌着创意和活力的团队，在越来越关注严谨和灵活的过程中成长起来，我们对前端的需求如此强烈，如果你也身在其中你会看到','Href':'http://ued.ctrip.com/'}, {'Name':'Mozilla','Title':'Mozilla 开发者网络MDN','Href':'https://developer.mozilla.org/zh-CN/'}, {'Name':'360奇舞团','Title':'','Href':'http://www.75team.com/'}, {'Name':'爱词霸UED','Title':'','Href':'http://ued.iciba.com/'}, {'Name':'19楼UED','Title':'','Href':'http://blog.19ued.com/'}, {'Name':'迅雷CUED','Title':'','Href':'http://cued.xunlei.com/'}, {'Name':'MyEChinese UED','Title':'','Href':'http://ued.myechinese.com/'}, {'Name':'昆仑游戏UED','Title':'','Href':'http://www.gameued.com/'}, {'Name':'360UXC','Title':'','Href':'http://uxc.360.cn/'}, {'Name':'1号店UED','Title':'','Href':'http://ued.yhd.com/blog'}, {'Name':'京东设计中心','Title':'专业，创造力，激情，设计。京东用户体验设计部门，致力于创造更美好的电子商务购物体验。JDC关注于电子商务视觉设计、交互设计、用户研究、前端开发。','Href':'http://jdc.jd.com/'}, {'Name':'畅游视觉设计中心','Title':'','Href':'http://vc.changyou.com/'}, {'Name':'觉唯设计UED','Title':'','Href':'http://www.jiawin.com/topics/ued'}, ] },{ \"pageT2\":\"国外前端\", \"pageC2\":[ {'Name':'codrops','Title':'创意思维的有用资源和灵感','Href':'http://tympanus.net/codrops/'}, {'Name':'HTML5 UP','Title':'国外博客模板','Href':'http://www.gbtags.com/gb/demoviewer/8188/141c4fcb-a8ba-4e35-9cd6-cf370be68f32/index.html.htm'}, {'Name':'codepen','Title':'前端开发人员游乐场和代码编辑器在浏览器','Href':'http://codepen.io/'}, {'Name':'CSS-Tricks','Title':'','Href':'http://css-tricks.com/'}, {'Name':'WebPlatform','Title':'','Href':'http://www.webplatform.org/'}, {'Name':'SmashingMagazine','Title':'smashingmagazine是为WEB开发人员提供的一个在线杂志','Href':'http://smashingmagazine.com'}, {'Name':'cssZenGarden','Title':'CSS禅意花园','Href':'http://www.csszengarden.com/'}, {'Name':'HTML & CSS','Title':'学习HTML代码&；CSS初学者&；先进','Href':'http://learn.shayhowe.com/'}, {'Name':'Navnav','Title':'响应式导航栏菜单教程，实例和演示','Href':'http://navnav.co/'}, {'Name':'Codyhouse','Title':'免费的HTML，CSS，JS掘金','Href':'https://codyhouse.co/'}, {'Name':'Gibbon','Title':'让你的员工更聪明。','Href':'https://gibbon.co/'}, {'Name':'Gotoandlearng','Title':'交互式开发的免费视频教程','Href':'http://gotoandlearn.com/'}, {'Name':'CSS Wizardry','Title':'前端架构与性能工程','Href':'http://csswizardry.com/'}, {'Name':'Tutorialzine','Title':'网络开发教程和资源','Href':'http://tutorialzine.com/'}, {'Name':'SitePoint','Title':'学习HTML，CSS，JavaScript，PHP，Ruby；响应式设计','Href':'http://www.sitepoint.com/'}, {'Name':'Hakim','Title':'Hakim El Hattab','Href':'http://hakim.se/'}, {'Name':'CssDeck','Title':'HTML5，CSS3，js演示、创作和实验','Href':'http://cssdeck.com/'}, {'Name':'WebPlatform','Title':'最新的关于如何使用的信息技术运行的网站的HTML，CSS，JavaScript和更多。','Href':'https://www.webplatform.org/'}, {'Name':'Lynda','Title':'学习技术，创新和商业技能，你可以使用今天。','Href':'http://www.lynda.com/'}, {'Name':'CssWinner','Title':'网页设计奖- CSS画廊网站奖的启示','Href':'http://www.csswinner.com/'}, {'Name':'Smashing Magazine','Title':'业界权威，web 设计很赞','Href':'http://www.smashingmagazine.com/'}, {'Name':'Tuts','Title':'国外知名开发者网站','Href':'http://hub.tutsplus.com/'}, {'Name':'DeveloperDrive','Title':'优质前端技术信息','Href':'http://www.developerdrive.com/'}, {'Name':'CSS-TRICKS','Title':'左边这位是大神','Href':'http://css-tricks.com/'}, {'Name':'Web Designer Wall','Title':'优质 Html5,CSS3等教程','Href':'http://webdesignerwall.com/'}, {'Name':'Tutorialzine','Title':'大量 web 教程和资源','Href':'http://tutorialzine.com/'}, {'Name':'Inspect Element','Title':'CSS,wordpress 相关教程挺多','Href':'http://inspectelement.com/'}, {'Name':'Codrops','Title':'设计、交互、CSS','Href':'http://tympanus.net/codrops/'}, {'Name':'Jake Rutter','Title':'Jquery 作者，不解释了','Href':'http://www.onerutter.com/'}, {'Name':'Paul Irish','Title':'大神,Google Chrome团队,Yeoman','Href':'http://www.paulirish.com/'}, {'Name':'Krasimir Tsonev','Title':'html5,ccs3,javascript','Href':'http://krasimirtsonev.com/blog'}, {'Name':'HTML5 Rocks','Title':'html5权威网站','Href':'http://www.html5rocks.com/en/'}, {'Name':'A List Apart','Title':'可以改变世界的文章','Href':'http://alistapart.com/'}, ] },{ \"pageT2\":\"前端大会\", \"pageC2\":[ {'Name':'阿里技术嘉年华','Title':'这是一场专属于的“技术盛宴”，倡导。','Href':'http://adc.alibabatech.org/'}, {'Name':'HTML5梦工场','Title':'','Href':'http://www.html5dw.com/'}, {'Name':'中国 CSS 开发者大会','Title':'','Href':'http://css.w3ctech.com/'}, {'Name':'前端圈','Title':'','Href':'http://fequan.com/'}, {'Name':'JS中国开发者大会','Title':'','Href':'http://jsconf.cn/'}, {'Name':'破茧','Title':'WebReBuild.org第九届年会-2015·破茧','Href':'http://www.webrebuild.org/'}, {'Name':'JS中国开发者大会','Title':'','Href':'http://jsconf.cn/'} ] }]},{ \"pageT1\":\"CSS/HTML\", \"pageC1\":[{ \"pageT2\":\"CSS\", \"pageC2\":[ {'Name':'CSS参考手册','Title':'web前端开发参考手册系列\"','Href':'http://css.doyoe.com/'}, {'Name':'CSS3参考手册','Title':'CSS3中文参考指南张鑫旭\"','Href':'http://www.zhangxinxu.com/css3/'}, {'Name':'CSS3参考手册','Title':'DIVCSS-CSS3手册-DIVCSS5\"','Href':'http://www.divcss5.com/css3/'}, {'Name':'cssReset','Title':'','Href':'http://www.cssreset.com/'}, {'Name':'IE默认CSS','Title':'','Href':'http://www.iecss.com/'}, {'Name':'浏览器hack大全','Title':'','Href':'http://browserhacks.com/'}, {'Name':'CSS Hack Table','Title':'','Href':'http://swordair.com/tools/css-hack-table/'}, {'Name':'cssValues','Title':'','Href':'http://cssvalues.com/'}, {'Name':'animate动画库','Title':'','Href':'http://daneden.github.io/animate.css/'}, {'Name':'CSS3lib动画库','Title':'','Href':'http://css3lib.alloyteam.com/'}, {'Name':'css3please','Title':'','Href':'http://css3please.com/'}, {'Name':'cubic-bezier','Title':'cubic-bezier贝塞尔曲线CSS3动画工具','Href':'http://cubic-bezier.com/'}, {'Name':'CSS SANS','Title':'CSS绘制字母','Href':'http://yusugomori.com/projects/css-sans/fonts/'}, {'Name':'css3ClickChart','Title':'','Href':'http://css3clickchart.com/'}, ] },{ \"pageT2\":\"HTML5\", \"pageC2\":[ {'Name':'html5基地','Title':'','Href':'http://html5.360.cn/'}, {'Name':'html5中国','Title':'','Href':'http://www.html5cn.org/'}, {'Name':'HTML5新增标签','Title':'','Href':'http://caibaojian.com/html5/index.html'}, {'Name':'5+ App','Title':'','Href':'http://ask.dcloud.net.cn/explore/'}, {'Name':'MAKA网站快速制作','Title':'','Href':'http://create.maka.im/user/login'}, {'Name':'最酷','Title':'','Href':'http://www.zuiku.com/'}, {'Name':'爱果果','Title':'','Href':'http://www.iguoguo.net/'}, {'Name':'ImpactJS','Title':'ImpactJS是一个基于JavaScript的HTML5游戏引擎，同时支持PC和移动平台浏览器。它是目前除了Construct2之外最受欢迎的HTML5游戏引擎，使用需要支付99美元\"','Href':'http://impactjs.com/'}, {'Name':'createjs','Title':'CreateJS是Adobe官方赞助的开源开发框架，它大部分API都是基于Flash原有的API来模仿实现的，并且官方提供了直接把Flash动画转成JS数据包的工具，调用起来很方便\"','Href':'http://www.createjs.com/'}, {'Name':'craftyjs','Title':'Crafty是一个体积小、简单、轻量级的2D的HTML5游戏引擎，它提供了通过Canvas或DOM来绘制实体，提供了精灵Map以及SAT高级碰撞监测支持\"','Href':'http://craftyjs.com/'}, {'Name':'threejs','Title':'Three.js是一个轻量级的JavaScript库，用于在浏览器上创建和显示3D图形\"','Href':'http://threejs.org/'}, {'Name':'melonjs','Title':'melonJS是melonJS团队对Javascript热情以及开发经验的结晶，是一个简单、免费、而且独立的类库\"','Href':'http://melonjs.org/'}, {'Name':'gamejs','Title':'GameJs是一个轻量的JavaScript游戏引擎，用于基于HTML5 Canvas的游戏开发\"','Href':'http://gamejs.org/'}, {'Name':'LimeJS','Title':'LimeJS是一个JavaScript游戏开发框架，允许开发者创建基于HTML5的游戏，支持主流浏览器包括iOS\"','Href':'http://www.limejs.com/'}, {'Name':'audio5js','Title':'HTML5 音频真棒，很容易实现，性能也很好。唯一能阻止你使用的可能就是旧版浏览器不支持。Audio5js 是一个轻量级的 JavaScript 库 ，很好地解决了这一兼容性问题\"','Href':'http://zohararad.github.io/audio5js/'}, {'Name':'小呆xd','Title':'H5广告案例分析\"','Href':'http://www.zcool.com.cn/u/886921'}, ] },{ \"pageT2\":\"动画库\", \"pageC2\":[ {'Name':'Animate.css','Title':'','Href':'http://daneden.github.io/animate.css/'}, {'Name':'Effeckt.css','Title':'','Href':'http://h5bp.github.io/Effeckt.css/'}, {'Name':'magic','Title':'','Href':'http://minimamente.com/example/magic_animations/'}, {'Name':'Normalize.css','Title':'','Href':'http://necolas.github.io/normalize.css/'}, {'Name':'CSS Reset','Title':'','Href':'http://cssreset.com/'}, {'Name':'css3ClickChart','Title':'','Href':'http://css3clickchart.com/#box-sizing'}, {'Name':'css3please','Title':'','Href':'http://css3please.com/'}, {'Name':'csshake抖动库','Title':'','Href':'http://www.htmleaf.com/css3/css3donghua/201501061116.html'}, ] },{ \"pageT2\":\"炫酷效果\", \"pageC2\":[ {'Name':'HTML5超炫3D元素周期表','Title':'','Href':'http://www.htmleaf.com/Demo/201409298.html'}, {'Name':'基于snabbt.js的精彩动画','Title':'','Href':'http://www.htmleaf.com/Demo/201501061113.html'}, {'Name':'css3的画廊图片切换3d翻转效果','Title':'','Href':'http://www.htmleaf.com/css3/css3donghua/2014100881.html'}, {'Name':'snabbt.js','Title':'','Href':'http://www.htmleaf.com/jQuery/Image-Effects/201501061112.html'}, {'Name':'5+ App','Title':'','Href':'http://ask.dcloud.net.cn/explore/'}, ] }]},{ \"pageT1\":\"JavaScript\", \"pageC1\":[{ \"pageT2\":\"原生开发\", \"pageC2\":[ {'Name':'原生JavaScript学习','Title':'','Href':'http://fgm.cc/learn/'}, {'Name':'JavaScript资源','Title':'JavaScript 资源大全中文版','Href':'https://github.com/jobbole/awesome-javascript-cn'}, {'Name':'MozillaJavaScriptGuide','Title':'Mozilla Developer Network出的JS教程','Href':'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide'}, {'Name':'GoogleJavaScriptGuide','Title':'','Href':'http://chajn.org/jsguide/javascriptguide.html'}, {'Name':'JavaScriptSource','Title':'高质量JS源码实例分享学习网站','Href':'http://www.javascriptsource.com/'}, {'Name':'JS秘密花园','Title':'JavaScript秘密花园是一个不断更新，主要关心JavaScript一些古怪用法的文档','Href':'http://bonsaiden.github.io/JavaScript-Garden/zh/'}, {'Name':'runjs','Title':'RunJS,在线编写、展示html、js、css代码，拥有实时预览','Href':'http://runjs.cn/'}, {'Name':'WebAPP-html5网页游戏','Title':'这里是小宇博客的html5技术实验室','Href':'http://html5.huceo.com/'}, {'Name':'jQuery Exercise','Title':'要想掌握jQuery？只是练习，练习，练习。当你完成所有的演练，你是大师。','Href':'http://jqexercise.droppages.com/'}, ] },{ \"pageT2\":\"JavaScript库\", \"pageC2\":[ {'Name':'jQuery','Title':'','Href':'http://jquery.com/'}, {'Name':'AngularJS','Title':'','Href':'http://angularjs.org/'}, {'Name':'YUI3','Title':'','Href':'http://yuilibrary.com/'}, {'Name':'knockout','Title':'','Href':'http://knockoutjs.com/'}, {'Name':'Dojo','Title':'','Href':'http://dojotoolkit.org/'}, {'Name':'MooTools','Title':'','Href':'http://mootools.net/'}, {'Name':'KISSY','Title':'','Href':'http://docs.kissyui.com/'}, {'Name':'Backbone','Title':'','Href':'http://backbonejs.org/'}, {'Name':'ExtJS','Title':'','Href':'http://www.sencha.com/products/extjs/'}, {'Name':'Prototype','Title':'','Href':'http://prototypejs.org/'}, {'Name':'emberjs','Title':'','Href':'http://emberjs.com/'}, {'Name':'bounce.js','Title':'','Href':'http://bouncejs.com/'}, {'Name':'Zepto','Title':'Zepto API 文档','Href':'http://zeptojs.com/'}, {'Name':'Zepto API','Title':'Zepto API - GMU API 文档','Href':'http://gmu.baidu.com/doc/2.0.5/'}, ] },{ \"pageT2\":\"jQuery插件\", \"pageC2\":[ {'Name':'jQuery速查表','Title':'','Href':'http://www.jq22.com/chm/jquery1.8.3.html'}, {'Name':'jQuery API 中文文档','Title':'jQuery 是一个兼容多浏览器的 JavasSript 框架','Href':'http://www.css88.com/jqapi-1.9/'}, {'Name':'jQuery插件库','Title':'','Href':'http://www.jq22.com/'}, {'Name':'jQuery-School','Title':'国内最大的jquery原创分享社区','Href':'http://www.jq-school.com/'}, {'Name':'jQuery之家','Title':'','Href':'http://www.htmleaf.com/'}, {'Name':'jQueryUI','Title':'jQueryUI是一套jQuery的页面UI插件，包含很多种常用的页面效果，例如 Tab切换 、对话框、拖放效果、日期选择、颜色选择、数据排序、窗体大小调整等','Href':'http://jqueryui.com/'}, {'Name':'jQuery Transit 动画库','Title':'','Href':'http://www.htmleaf.com/jQuery/Layout-Interface/201501281289.html'}, {'Name':'osChina jQuery插件','Title':'','Href':'http://www.oschina.net/project/tag/273/jquery'}, {'Name':'jqueryfuns','Title':'','Href':'http://www.jqueryfuns.com/'}, {'Name':'fullPage.js','Title':'一款JQuery的插件，让你轻松实现满屏滚动','Href':'https://github.com/alvarotrigo/fullPage.js'}, {'Name':'开源编辑器','Title':'','Href':'http://www.biaodianfu.com/editor.html'}, {'Name':'myfocus','Title':'','Href':'http://demo.jb51.net/js/myfocus/'}, ] },{ \"pageT2\":\"nodejs\", \"pageC2\":[ {'Name':'node.js官方','Title':'Node.js是一个基于Chrome V8引擎封装后运行的一个平台','Href':'http://www.nodejs.org/'}, {'Name':'node.js中文社区','Title':'CNode 社区由一批热爱 Node.js 技术的工程师发起，目前已经吸引了互联网各个公司的专业技术人员加入','Href':'http://cnodejs.org/'}, {'Name':'grunt.js官方','Title':'Grunt是一个基于node.js的自动化项目构建工具，支持压缩、合并、测试等功能','Href':'http://gruntjs.com/'}, {'Name':'grunt.js中文站点','Title':'','Href':'http://gruntjs.cn/http://gruntjs.cn/'}, {'Name':'Yeoman','Title':'一款前端自动化工作流工具，集成Grunt和bower，实现了项目的快速搭建、自动化前端构建，以及前端包依赖和包管理','Href':'http://yeoman.io/'}, {'Name':'gulpjs官方','Title':'比Grunt更简单的自动化的项目构建利器','Href':'http://gulpjs.com/'}, {'Name':'智图gulp插件','Title':'腾讯智图，一款图片压缩产品，支持生成webp/jpg/png。此为gulp插件，基于智图的api，实测压缩率大于Tinypng','Href':'https://github.com/targetkiller/gulp-imageisux'}, ] },{ \"pageT2\":\"MVC\", \"pageC2\":[ {'Name':'backbonejs','Title':'Backbone.js是一个可以在前端组织MVC的javascript框架','Href':'http://backbonejs.org/'}, {'Name':'angularjs','Title':'AngularJS是由Google创建的一种JS框架，使用它可以扩展应用程序中的HTML词汇，从而在web应用程序中使用HTML声明动态内容','Href':'https://angularjs.org/'}, {'Name':'emberjs','Title':'Ember.js同样是一个用于创建web应用的JavaScript MVC 框架','Href':'http://emberjs.com/'}, {'Name':'knockoutjs','Title':'Knockout 是个JavaScript library，帮助创建丰富的显示和编辑器UI，通过干净的底层数据模型，你可以在任何时候动态更新UI的选择部分','Href':'http://knockoutjs.com/'}, {'Name':'vuejs','Title':'数据驱动的组件，为现代化的 Web 界面而生','Href':'http://cn.vuejs.org/'}, ] }]},{ \"pageT1\":\"移动端/响应式\", \"pageC1\":[{ \"pageT2\":\"移动端\", \"pageC2\":[ {'Name':'ionic','Title':'Ionic(ionicframework)一款接近原生的Html5移动App开发框架 会html css js就可以开发app 创建精彩的应用 从这里开始。','Href':'http://www.ionic.wang/'}, {'Name':'jQueryMobile','Title':'','Href':'http://jquerymobile.com/'}, {'Name':'Joapp','Title':'','Href':'http://joapp.com/'}, {'Name':'5+ App','Title':'','Href':'http://www.dcloud.io/docs/api/index.shtml'}, {'Name':'FrozenUI','Title':'','Href':'http://frozenui.github.io/'}, {'Name':'去哪儿','Title':'','Href':'http://ued.qunar.com/mobile/page/'}, {'Name':'QApp','Title':'','Href':'http://ued.qunar.com/mobile/qapp/doc/'}, {'Name':'微信JS-SDK','Title':'','Href':'http://203.195.235.76/jssdk/'}, ] },{ \"pageT2\":\"响应式开发\", \"pageC2\":[ {'Name':'Bootstrap','Title':'','Href':'http://www.bootcss.com/'}, {'Name':'UI Kit','Title':'','Href':'http://getuikit.com/'}, {'Name':'GetWebplate','Title':'','Href':'http://getwebplate.com/'}, {'Name':'Cardinal','Title':'','Href':'http://cardinalcss.com/'}, {'Name':'Pure','Title':'','Href':'http://purecss.io/'}, {'Name':'Base','Title':'','Href':'http://base.gs/'}, ] },{ \"pageT2\":\"模块化\", \"pageC2\":[ {'Name':'commonjs','Title':'','Href':'http://www.commonjs.org/'}, {'Name':'seajs','Title':'','Href':'http://seajs.org/docs/'}, {'Name':'requirejs','Title':'','Href':'http://requirejs.org/'}, {'Name':'nodejs','Title':'','Href':'http://nodejs.org/'}, {'Name':'curl.js','Title':'','Href':'https://github.com/cujojs/curl'}, ] }]},{ \"pageT1\":\"文档/资源库\", \"pageC1\":[{ \"pageT2\":\"前端文档\", \"pageC2\":[ {'Name':'HTML','Title':'','Href':'http://www.w3cschool.cc/tags/html-reference.html'}, {'Name':'CSS','Title':'','Href':'http://www.w3cschool.cc/cssref/css-reference.html'}, {'Name':'CSS3','Title':'','Href':'http://www.divcss5.com/css3/'}, {'Name':'HTML5','Title':'','Href':'http://www.w3.org/html/ig/zh/wiki/HTML5'}, {'Name':'JavaScript','Title':'','Href':'http://www.php100.com/manual/javascript.html'}, {'Name':'jQuery','Title':'','Href':'http://jquery.cuishifeng.cn/'}, {'Name':'NodeJs','Title':'','Href':'http://nodeapi.ucdok.com/'}, {'Name':'AngularJS','Title':'','Href':'http://www.apjs.net/'}, {'Name':'5+ App','Title':'','Href':'http://www.html5plus.org/doc/h5p.html'}, ] },{ \"pageT2\":\"静态资源库\", \"pageC2\":[ {'Name':'百度静态资源公共库','Title':'','Href':'http://cdn.code.baidu.com/'}, {'Name':'CDNJS','Title':'Realtime search by ','Href':'https://cdnjs.com/'}, {'Name':'BootCDN','Title':'','Href':'http://www.bootcdn.cn/'}, {'Name':'前端静态资源','Title':'','Href':'http://festatic.aliapp.com/'}, {'Name':'CDNJS.NET','Title':'','Href':'http://www.cdnjs.net/'}, {'Name':'前端静态资源','Title':'','Href':'http://festatic.aliapp.com/'}, {'Name':'极客前端资源','Title':'','Href':'http://wiki.jikexueyuan.com/list/front-end/'}, {'Name':'看云前端资源','Title':'','Href':'http://www.kancloud.cn/search?keyword=%E5%89%8D%E7%AB%AF/'}, {'Name':'JS前端开发群规','Title':'','Href':'http://www.kancloud.cn/jikeytang/qq/87646'}, ] },{ \"pageT2\":\"前端书籍\", \"pageC2\":[ {'Name':'JavaScript高级程序设计(第3版)','Title':'','Href':'http://search.dangdang.com/?key=JavaScript高级程序设计(第3版)'}, {'Name':'JavaScript权威指南(第6版)','Title':'','Href':'http://search.dangdang.com/?key=JavaScript权威指南(第6版)'}, {'Name':'JavaScript DOM编程艺术(第2版)','Title':'','Href':'http://search.dangdang.com/?key=JavaScript DOM编程艺术(第2版)'}, {'Name':'JavaScript设计模式','Title':'s设计模式也是要学的，此书把js的设计模式讲得非常清晰，一点不晦涩，看起来没多少难度。','Href':'http://search.dangdang.com/?key=JavaScript设计模式'}, {'Name':'javascript面向对象编程指南','Title':'风格轻松易懂，比较适合初学者，原型那块儿讲得透彻，12种继承方式','Href':'http://search.dangdang.com/?key=javascript面向对象编程指南'}, {'Name':'你不知道的javascript','Title':'狙击js核心细节，闭包、原型、this讲得都还清楚','Href':'http://search.dangdang.com/?key=你不知道的javascript'}, {'Name':'javascript框架设计','Title':'如果初看此书，会觉得此书有罗列代码之嫌。在我看来，此书讲究的是框架的全局观。','Href':''}, {'Name':'','Title':'','Href':''}, {'Name':'','Title':'','Href':''}, {'Name':'','Title':'','Href':''}, {'Name':'','Title':'','Href':''}, {'Name':'锋利的jQuery(第2版)','Title':'','Href':'http://search.dangdang.com/?key=锋利的jQuery(第2版)'}, {'Name':'Backbone.js入门教程第二版','Title':'Backbone.js提供了一套web开发的框架，通过Models进行key-value绑定及自定义事件处理，通过Collections提供一套丰富的API用于枚举功能，通过Views来进行事件处理及与现有的Application通过RESTful JSON接口进行交互.它是基于jQuery和underscore的一个前端js框架。','Href':'http://www.kancloud.cn/kancloud/backbonejs-learning-note/49378'}, {'Name':'css揭秘','Title':'不屑于全面讲css3各属性','Href':''}, {'Name':'css权威指南','Title':'css基础知识点那是讲得非常清楚的。什么层叠优先级、line-height啥的。不是随便一本书都敢叫“权威指南”的','Href':''}, {'Name':'CSS网站布局实录(第二版)','Title':'','Href':'http://search.dangdang.com/?key=CSS网站布局实录(第二版)'}, {'Name':'HTML5与CSS3权威指南','Title':'','Href':'http://search.dangdang.com/?key=HTML5与CSS3权威指南'}, {'Name':'HTML5移动Web开发指南','Title':'','Href':'http://search.dangdang.com/?key=HTML5移动Web开发指南'}, {'Name':'前端开发者手册','Title':'这是任何人都可以用来学习前端的实践手册, 它概述并讨论了前端工程的实践: 该如何学习以及实践时该使用什么工具.','Href':'http://www.kancloud.cn/kancloud/front-end-dev-handbook/75919'}, {'Name':'前端性能优化指南','Title':'参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。','Href':'http://www.kancloud.cn/kancloud/web_performance_optimization/80987'}, {'Name':'响应式设计快速指南','Title':'响应式设计和开发已然成为了标配，那么好了，如何更好的进行响应式开发呢？ 小编摘选了优设网的一些关于响应式设计的精华文章~','Href':'http://www.kancloud.cn/kancloud/responsive-typography/70844'}, {'Name':'Web前端干货铺','Title':'收藏那些优秀的技术文章，多数转载自前端大牛的博客。作者人品不定，缓慢更新，想打造一份前端干货集子，希望对您有帮助。','Href':'http://www.kancloud.cn/jaya1992/fe-notes/82231'}, {'Name':'JS前端开发群规','Title':'JS前端开发群规 - 492107297','Href':'http://www.kancloud.cn/jikeytang/qq/87646'}, {'Name':'fouber的前端工程专题','Title':'或许现在很多企业和团队尚未重视前端工程，或许前端工程在很多人眼里还只是“构建工具”的代名词，又或许未来前端领域的变革使得一切工程问题从根本上得到解决。不管怎样，我只是希望当下能认真的记录自己在前端工程领域的所见所想，与正在经历前端工程化改进，并被此过程困扰的同学交流心得。','Href':'http://www.kancloud.cn/digest/fis/61586'}, {'Name':'精通正则表达式(第3版)','Title':'','Href':'http://search.dangdang.com/?key=精通正则表达式(第3版)'}, {'Name':'HTTP权威指南','Title':'','Href':'http://search.dangdang.com/?key=HTTP权威指南'}, {'Name':'Node.js开发指南','Title':'','Href':'http://search.dangdang.com/?key=Node.js开发指南'}, {'Name':'Node.js实战','Title':'','Href':'http://search.dangdang.com/?key=Node.js实战'}, ] }]},{ \"pageT1\":\"免费素材\", \"pageC1\":[{ \"pageT2\":\"设计导航\", \"pageC2\":[ {'Name':'学UI网设计导航','Title':'','Href':'http://hao.xueui.cn/'}, {'Name':'uesoso网络收藏','Title':'','Href':'http://so.uehtml.com/'}, {'Name':'设计派导航','Title':'','Href':'http://hao.shejipai.cn/'}, {'Name':'觉唯网站地图','Title':'','Href':'http://www.jiawin.com/sitemap'}, {'Name':'WEB前端资源网','Title':'','Href':'http://www.58img.com/hao'}, ] },{ \"pageT2\":\"图标库\", \"pageC2\":[ {'Name':'阿里巴巴矢量图','Title':'','Href':'http://www.iconfont.cn/'}, {'Name':'icomoon','Title':'','Href':'https://icomoon.io/'}, {'Name':'FontAwesome','Title':'','Href':'http://fontawesome.io/'}, {'Name':'Ionicons','Title':'','Href':'http://ionicons.com/'}, {'Name':'iconfinder','Title':'','Href':'https://www.iconfinder.com/'}, ] },{ \"pageT2\":\"素材下载\", \"pageC2\":[ {'Name':'dribbble','Title':'国外前端设计网站','Href':'https://dribbble.com/'}, {'Name':'ZCOOL站酷','Title':'中国最具人气的设计师互动平台，300万设计师聚集地。','Href':'http://www.zcool.com.cn/'}, {'Name':'觉唯设计','Title':'以用户为中心的设计理念，专注于用户体验设计','Href':'http://www.jiawin.com/topics/resource'}, {'Name':'UI中国','Title':'我们将打造中国最专业的 UI 设计交流平台','Href':'http://www.ui.cn/'}, {'Name':'P大点S','Title':'P大点S-PS爱好者。这里是PS爱好者的小团队','Href':'http://www.pdadians.com/'}, {'Name':'视觉','Title':'视觉中国设计师社区','Href':'http://shijue.me/'}, {'Name':'Sketch中文网','Title':'Sketch中文网是一个以中文内容介绍Sketch这款Mac设计工具的社区，在这里分享最新的Sketch中文手册，以及使用技巧。','Href':'http://www.sketchcn.com/'}, {'Name':'365psd','Title':'','Href':'http://cn.365psd.com/'}, {'Name':'17素材','Title':'','Href':'http://www.17sucai.com/'}, {'Name':'千图网','Title':'','Href':'http://www.58pic.com/'}, {'Name':'UE设计平台','Title':'','Href':'http://www.uehtml.com/'}, {'Name':'优设-UISDC','Title':'','Href':'http://www.uisdc.com/'}, {'Name':'学UI网','Title':'','Href':'http://www.xueui.cn/'}, {'Name':'前端资源网','Title':'','Href':'http://www.58img.com/'}, {'Name':'xw素材网','Title':'','Href':'http://www.xwcms.net/'}, {'Name':'UI.PARADE','Title':'','Href':'http://www.uiparade.com/'}, {'Name':'CLIPART.ME','Title':'','Href':'http://cn.clipart.me/'}, {'Name':'站长素材','Title':'','Href':'http://sc.chinaz.com/'}, {'Name':'懒人之家','Title':'','Href':'http://www.lanrenzhijia.com/'}, {'Name':'科e互联','Title':'','Href':'http://www.internetke.com/'}, {'Name':'非凡图库','Title':'','Href':'http://www.ffpic.com/'}, ] }]},{ \"pageT1\":\"数据接口/平台\", \"pageC1\":[{ \"pageT2\":\"开放平台\", \"pageC2\":[ {'Name':'百度开放云平台','Title':'','Href':'http://developer.baidu.com/'}, {'Name':'腾讯开放平台','Title':'','Href':'http://open.qq.com/'}, ] },{ \"pageT2\":\"WebApi\", \"pageC2\":[ {'Name':'云聚数据','Title':'','Href':'http://www.36wu.com/Service'}, {'Name':'常用接口大全','Title':'','Href':'http://www.bejson.com/go.html?u=http://www.bejson.com/webInterface.html'}, {'Name':'apicloud','Title':'','Href':'http://apicloud.com/'}, {'Name':'微信公众平台开发者文档','Title':'公众平台是为微信用户提供服务的平台，而公众平台开发接口则是提供服务的基础，开发者在公众平台网站中创建公众号、获取接口权限后，可以通过阅读本接口文档来帮助开发。','Href':'http://mp.weixin.qq.com/wiki/home/index.html'}, ] }]},{ \"pageT1\":\"实用工具\", \"pageC1\":[{ \"pageT2\":\"编辑器\", \"pageC2\":[ {'Name':'Sublime Text','Title':'','Href':'http://www.sublimetext.com/'}, {'Name':'Atom','Title':'','Href':'https://atom.io/'}, {'Name':'HBuilder','Title':'','Href':'http://www.dcloud.io/'}, {'Name':'WebStorm','Title':'','Href':'http://www.jetbrains.com/webstorm/'}, {'Name':'Visual Studio Code','Title':'','Href':'https://www.visualstudio.com/products/code-vs'}, {'Name':'Dreamweaver','Title':'','Href':'http://www.adobe.com/cn/products/dreamweaver.html'}, {'Name':'IntelliJIDEA','Title':'','Href':'http://www.jetbrains.com/idea/'}, {'Name':'Aptana','Title':'','Href':'http://www.aptana.com/'}, ] },{ \"pageT2\":\"切图工具\", \"pageC2\":[ {'Name':'Zeplin','Title':'切图工具','Href':'http://www.zeplin.io/'}, {'Name':'PxCook','Title':'Aodbe ARI切图工具','Href':''}, {'Name':'马克鳗','Title':'设计稿标注、测量神器','Href':'http://www.getmarkman.com'}, ] },{ \"pageT2\":\"在线编辑器\", \"pageC2\":[ {'Name':'Online IDE','Title':'编译和执行程序的在线|在线IDE','Href':'http://www.compileonline.com/'}, {'Name':'CODEPEN','Title':'','Href':'http://codepen.io/'}, {'Name':'RunJS','Title':'','Href':'http://runjs.cn/code'}, {'Name':'JSFIDDLE','Title':'','Href':'http://jsfiddle.net/'}, {'Name':'JS Bin','Title':'','Href':'http://jsbin.com/?html,output'}, {'Name':'cssdeck','Title':'','Href':'http://cssdeck.com/'}, {'Name':'jsdo.it','Title':'','Href':'http://jsdo.it/'}, {'Name':'dabblet','Title':'','Href':'http://dabblet.com/'}, ] },{ \"pageT2\":\"插件\", \"pageC2\":[ {'Name':'CODEPEN','Title':'','Href':'http://codepen.io/'}, {'Name':'FireBUG','Title':'Firebug插件集成了浏览网页的同时随手可得的丰富开发工具，你可以对任何网页的 CSS、HTML 和 JavaScript 进行实时编辑、调试和监控\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/firebug/'}, {'Name':'cssUsage','Title':'css-usage插件用于察看哪些CSS被用到\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/css-usage/'}, {'Name':'YSlow','Title':'YSlow是Yahoo发布的一款基于FireFox的插件，用于全面分析网站性能\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/yslow/'}, {'Name':'WebDeveloper','Title':'Web Developer插件用于页面强大的元素分析，它加入了几个菜单与一条工具栏以及多种网页开发者工具\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/web-developer/'}, {'Name':'HtmlValidator','Title':'html-validator插件用于验证网站是否遵守w3c标准，装上该插件后，可以在页面源码模式中检测你的html代码\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/html-validator/'}, {'Name':'colorzilla','Title':'colorzilla插件用于页面去色、渐变生成等\"','Href':'https://addons.mozilla.org/zh-CN/firefox/addon/colorzilla/'}, {'Name':'httpfox','Title':'httpfox插件用于HTTP分析器的扩展\"','Href':'https://addons.mozilla.org/ZH-cn/firefox/addon/httpfox/'}, {'Name':'ChromeDevTools','Title':'chrome dev tools\"','Href':'https://developers.google.com/chrome-developer-tools/?hl=zh-CN'}, {'Name':'DEBUGGER','Title':'一款IE浏览器调试工具 ：DOM inspector, Javascript debugger, HTTP headers viewer, Cookies viewer\"','Href':'http://www.debugbar.com/'}, {'Name':'IEToolbar','Title':'\"','Href':'http://www.microsoft.com/en-us/download/details.aspx?id=18359'}, ] },{ \"pageT2\":\"性能测试\", \"pageC2\":[ {'Name':'WebPageTest','Title':'网站性能和优化测试','Href':'http://www.webpagetest.org/'}, {'Name':'阿里测','Title':'','Href':'http://www.alibench.com/'}, {'Name':'SiteSpeed','Title':'检查站点速度','Href':'http://sitespeed.me/'}, {'Name':'Pingdom','Title':'网站速度测试','Href':'http://tools.pingdom.com/'}, {'Name':'GTmetrix','Title':'','Href':'http://gtmetrix.com/'}, {'Name':'HttpWatch','Title':'','Href':'http://www.httpwatch.com/'}, {'Name':'BROWSERSHOTS','Title':'','Href':'http://browsershots.org/'}, {'Name':'Mobile testing','Title':'','Href':'http://www.webpagetest.org/mobile'}, {'Name':'Feed validator','Title':'','Href':'http://jigsaw.w3.org/css-validator/'}, {'Name':'性能工具','Title':'','Href':'http://www.w3cplus.com/performance/performance-tools.html'}, ] },{ \"pageT2\":\"格式化\", \"pageC2\":[ {'Name':'HTML格式化','Title':'','Href':'http://tool.lu/html/'}, {'Name':'CSS格式化','Title':'','Href':'http://tool.lu/css/'}, {'Name':'JS格式化','Title':'','Href':'http://tool.lu/js/'}, {'Name':'JSON格式化','Title':'','Href':'http://tool.lu/json/'}, {'Name':'在线工具','Title':'','Href':'http://tool.lu/c/developer'}, {'Name':'XML格式化','Title':'','Href':'http://tool.oschina.net/codeformat/xml'}, {'Name':'SQL格式化','Title':'','Href':'http://tool.oschina.net/codeformat/sql'}, {'Name':'Less编译','Title':'','Href':'http://tool.oschina.net/less'}, {'Name':'HTML/CSS/JavaScript压缩','Title':'','Href':'http://tool.oschina.net/jscompress'}, ] },{ \"pageT2\":\"CSS3在线生成\", \"pageC2\":[ {'Name':'Preloaders','Title':'','Href':'http://preloaders.net/'}, {'Name':'Ultimate CSS Gradient Generator','Title':'','Href':'http://www.colorzilla.com/gradient-editor/'}, {'Name':'CSS3 Generator','Title':'','Href':'http://css3generator.com/'}, {'Name':'CSS3 Maker','Title':'','Href':'http://www.css3maker.com/'}, ] },{ \"pageT2\":\"加密/转码\", \"pageC2\":[ {'Name':'编码BASE64','Title':'Base64目前主要用于HTML5、移动开发等不考虑IE6的场景中。','Href':'http://tool.css-js.com/base64.html'}, {'Name':'加密/解密','Title':'','Href':'http://tool.oschina.net/encrypt'}, {'Name':'散列/哈希','Title':'','Href':'http://tool.oschina.net/encrypt?type=2'}, {'Name':'图片/BASE64转换','Title':'','Href':'http://tool.oschina.net/encrypt?type=4'}, {'Name':'进制转换','Title':'','Href':'http://tool.oschina.net/hexconvert'}, {'Name':'二维码生成/解码','Title':'','Href':'http://tool.oschina.net/qr'}, {'Name':'URL转码','Title':'','Href':'http://tool.oschina.net/encode?type=4'}, ] },{ \"pageT2\":\"其他工具\", \"pageC2\":[ {'Name':'正则表达式测试','Title':'','Href':'http://tool.oschina.net/regex'}, {'Name':'JiaThis分享','Title':'','Href':'http://www.jiathis.com/'}, {'Name':'Mob分享','Title':'','Href':'http://share.mob.com/'}, {'Name':'百度分享','Title':'','Href':'http://share.baidu.com/'}, {'Name':'BShare分享','Title':'','Href':'http://www.bshare.cn/'}, {'Name':'XAMPP','Title':'XAMPP是最流行的PHP开发环境','Href':'https://www.apachefriends.org/'}, {'Name':'Browsersync','Title':'省时的浏览器同步测试工具','Href':'http://www.browsersync.cn/'}, {'Name':'F5','Title':'Web开发免刷新工具','Href':'http://www.getf5.com/'}, {'Name':'国外buffer','Title':'','Href':'https://buffer.com/'}, {'Name':'AppCan','Title':'','Href':'http://www.appcan.cn/'}, {'Name':'AlloyPhoto图片处理','Title':'','Href':'http://tool.oschina.net/alloyphoto'}, {'Name':'代码着色','Title':'','Href':'http://tool.oschina.net/highlight'}, {'Name':'URL2PNG','Title':'','Href':'https://www.url2png.com/'}, {'Name':'ico制作','Title':'','Href':'http://www.bitbug.net/'}, {'Name':'GoPng','Title':'HTML5在线雪碧图片合成工具','Href':'http://alloyteam.github.io/gopng/'}, {'Name':'clippy','Title':'CSS clip-path maker','Href':'http://bennettfeely.com/clippy/'}, ] },{ \"pageT2\":\"代码托管\", \"pageC2\":[ {'Name':'GitHub 使用手册 - 基础篇','Title':'','Href':'http://wiki.jikexueyuan.com/project/github-basics/'}, {'Name':'GitHub Pages 指南','Title':'','Href':'http://wiki.jikexueyuan.com/project/github-pages-basics/'}, {'Name':'GitHub 开发指南','Title':'','Href':'http://wiki.jikexueyuan.com/project/github-developer-guides/'}, {'Name':'GitHub 秘籍','Title':'','Href':'http://wiki.jikexueyuan.com/project/github-secret/'}, {'Name':'Hexo 中文版','Title':'','Href':'http://wiki.jikexueyuan.com/project/hexo-document/'}, {'Name':'Git 教程','Title':'','Href':'http://wiki.jikexueyuan.com/project/git-tutorial/'}, {'Name':'Git 参考手册','Title':'本站为 Git 参考手册。目的是为学习与记忆 Git 使用中最重要、最普遍的命令提供快速翻阅。','Href':'http://gitref.justjavac.com/'}, {'Name':'Git 工作流指南','Title':'','Href':'http://wiki.jikexueyuan.com/project/git-workflow-tutorial/'}, {'Name':'Git Community Book 中文版','Title':'','Href':'http://wiki.jikexueyuan.com/project/git-community-book/'}, {'Name':'Pro Git','Title':'','Href':'http://wiki.jikexueyuan.com/project/pro-git/'}, {'Name':'Git 魔法','Title':'','Href':'http://wiki.jikexueyuan.com/project/git-magic/'}, {'Name':'Pro Git v2 中文版','Title':'','Href':'http://wiki.jikexueyuan.com/project/pro-git-two/'}, {'Name':'像 geek 一样写博客','Title':'','Href':'http://wiki.jikexueyuan.com/project/github-page/'}, ] }]},{ \"pageT1\":\"找工作\", \"pageC1\":[{ \"pageT2\":\"求职网站\", \"pageC2\":[ {'Name':'前端面试题目搜集','Title':'作者精心整理的的前端面试题，值得收藏~','Href':'http://www.kancloud.cn/digest/front-interview/86832',\"New\":\"1\"}, {'Name':'拉勾网','Title':'最专业的互联网招聘平台','Href':'http://www.lagou.com'}, {'Name':'哪上班','Title':'高质量互联网人才','Href':'https://www.nashangban.com/'}, {'Name':'内推网','Title':'互联网招聘内部推荐直招平台','Href':'http://www.neitui.me/'}, {'Name':'牛客网','Title':'专业IT笔试面试备考平台','Href':'http://www.nowcoder.com/'}, {'Name':'前端收藏夹','Title':'前端收藏夹，为你提供全面的前端学习资源汇总。','Href':'http://collect.w3ctrain.com/'}, {'Name':'whycss','Title':'前端网址导航是为国内前端界的朋友们倾力打造的前端资源聚合平台','Href':'http://www.whycss.com/'}, {'Name':'前端网址导航','Title':'最活跃的前端网址导航，最前端的圈子','Href':'http://www.daqianduan.com/nav'}, {'Name':'江湖录','Title':'前端的发展，离不开所有前仆后继的江湖人士，是他们，也是你们，创造了别具活力的前端生态圈。','Href':'http://sentsin.com/daohang/'}, {'Name':'UEDfans','Title':'最好用的UED导航！','Href':'http://uedfans.cn/'}, {'Name':'前端导航','Title':'','Href':'http://www.haorooms.com/nav'}, ] }]},{ \"pageT1\":\"我的链接\", \"pageC1\":[{ \"pageT2\":\"我的链接\", \"pageC2\":[ {'Name':'主页','Title':'爱折腾，爱运动，更爱游离于错综复杂的编码与逻辑中，无法自拔。','Href':'http://luuman.github.io/Home/'}, {'Name':'博客','Title':'因为有了危机感，所以会义无反顾。','Href':'http://luuman.github.io/'}, {'Name':'项目','Title':'开发项目','Href':'http://luuman.github.io/works/'}, {'Name':'原生Js','Title':'记录自己学习原生JavaScript的路径','Href':'http://luuman.github.io/works/'}, ] },{ \"pageT2\":\"国内博客\", \"pageC2\":[ // FontEnd {'Name':'信鑫-King','Title':'正因为不轻易就被人懂，所以我才有自己的价值。','Href':'http://www.ycjcl.cc/',\"New\":\"1\"}, {'Name':'墨鱼','Title':'小前端，大世界','Href':'http://liuxinyu.me/'}, {'Name':'青春样','Title':'YANGZJ1992S BLOG','Href':'http://www.qcyoung.com/'}, {'Name':'查新宇','Title':'Simple Note','Href':'http://newraina.com/',\"New\":\"1\"}, {'Name':'吴虹松','Title':'A web front-end programmers personal blog.','Href':'http://coolnuanfeng.github.io/'}, {'Name':'HcySunYang','Title':'Blogs and life','Href':'http://hcysun.me/'}, {'Name':'张运领','Title':'张运领的个人博客_web前端技术文章_前端学习','Href':'http://www.zhangyunling.com/'}, {'Name':'蛋糕仙人','Title':'技术人需要危机感','Href':'http://blog.gejiawen.com/'}, {'Name':'Meekdai','Title':'童话是一种生活态度，仅此而已！','Href':'http://www.meekdai.com/'}, {'Name':'侯锋博客','Title':'用简单质朴的思维、设计、创意、方法去解决复杂的问题...','Href':'http://blog.houfeng.net/'}, {'Name':'牛宝峰博客','Title':'一个人之所以有意思，是因为他大量阅读，习惯思考，放缓脚步，投入深度对话，并为自己创建了一个丰满的内心世界。','Href':'https://blog.niubaofeng.com/'}, {'Name':'Aidis Blog','Title':'竹杖芒鞋轻胜马','Href':'http://blog.aiditan.me/'}, {'Name':'nuysoft','Title':'这是万世奇平时写东西的地方','Href':'http://ursocute.github.io/'}, {'Name':'吕立青','Title':'画家与黑客是相似的：他们都是创造者，就好像作曲家，建筑师，以及作家一样，他们的目的是创造某种美好的事物。','Href':'http://blog.jimmylv.info/',\"New\":\"1\"}, {'Name':'CSS探索之旅','Title':'','Href':'http://blog.doyoe.com/',\"New\":\"1\"}, {'Name':'岁寒','Title':'任何事情，从现在开始做，都不晚！','Href':'https://lvwenhan.com/'}, {'Name':'白树','Title':'白树，目前就职于微信支付设计中心，负责移动端产品，擅长html5、css3、javascript','Href':'http://www.cnblogs.com/PeunZhang/',\"New\":\"1\"}, {'Name':'HyG','Title':'现实像块石头，精神像个蛋，石头虽然坚硬，可蛋里才是生命。','Href':'http://gaohaoyang.github.io/'}, {'Name':'黄玄','Title':'写写代码，做做设计，看看产品。世界那么大，我想去看看。','Href':'http://ebnbin.com/'}, {'Name':'天镶','Title':'尘世间一个迷途的小码农','Href':'http://lingyu.wang/'}, {'Name':'张鑫旭','Title':'','Href':'http://www.zhangxinxu.com/wordpress/',\"New\":\"1\"}, {'Name':'aibusy','Title':'','Href':'http://aibusy.com/blog/'}, {'Name':'Luke Qian','Title':'Luke的自留地','Href':'http://hmqk1995.github.io/'}, {'Name':'SmdCn','Title':'若还能识破一个个谎言，从阴暗中飞升出来，那就向前进吧，能改变这未来的，就只有你！','Href':'http://blog.smdcn.net/'}, {'Name':'Duan Hong','Title':'LIFE IS A STRUGGLE','Href':'http://dhong.co/'}, {'Name':'水墨寒','Title':'喜欢敲代码的感觉，相信编程是一门艺术，自诩为游弋在代码里的人生。','Href':'http://www.smohan.net/blog/',\"New\":\"1\"}, {'Name':'解旻','Title':'精英里的人渣，人渣中精华，我是极品人渣，我为自己代言','Href':'http://xieminis.me/'}, {'Name':'尹锋以为','Title':'LESS IS MORE','Href':'http://ingf.github.io/'}, {'Name':'木月土','Title':'杜超的个人主页','Href':'http://varwwwhtml.com/'}, {'Name':'ileyar','Title':'','Href':'http://www.ileyar.com/'}, {'Name':'心淡若水','Title':'','Href':'http://muo.me/'}, {'Name':'梦想的港湾','Title':'','Href':'https://www.mxgw.info/'}, {'Name':'于江水','Title':'','Href':'http://yujiangshui.com/'}, {'Name':'Kayo','Title':'跟大家分享折腾前端和 WordPress 的心得，同时夹杂着生活的点滴，借此遇上一些志同道合的人！','Href':'http://kayosite.com/'}, {'Name':'剧中人','Title':'90后天蝎男，前端工程师，全栈开发尝试者','Href':'https://www.bh-lay.com/',\"New\":\"1\"}, {'Name':'万世奇的博客','Title':'A Combat Engineer','Href':'http://nuysoft.com/'}, {'Name':'前端开发博客','Title':'cheris——努力成为业界优秀的前端分享博客','Href':'http://www.cheris.cn/'}, {'Name':'前端开发博客','Title':'专注于WEB前端开发,分享前端开发教程和前端资讯','Href':'http://caibaojian.com/'}, {'Name':'caibaojian','Title':'','Href':'http://caibaojian.com/'}, {'Name':'Jackie Wu','Title':'','Href':'http://www.wuchenglong.com/'}, {'Name':'netcan','Title':'','Href':'http://www.netcan666.com/'}, {'Name':'射雕天龙','Title':'这个世界有多么不给力，你就应该多么给自己力！','Href':'http://blog.wangjunfeng.com/'}, {'Name':'linux2me','Title':'','Href':'http://www.linux2me.com/'}, {'Name':'张雯莉','Title':'','Href':'http://zhangwenli.com/blog/'}, {'Name':'堂主','Title':'','Href':'http://www.osmn00.com/',\"New\":\"1\"}, {'Name':'彬go','Title':'','Href':'http://blog.bingo929.com/'}, {'Name':'武方博','Title':'','Href':'http://www.wufangbo.com/'}, {'Name':'潘魏增','Title':'','Href':'http://panweizeng.com/'}, {'Name':'廖雪峰','Title':'','Href':'http://www.liaoxuefeng.com/'}, {'Name':'三水清','Title':'','Href':'http://js8.in/'}, {'Name':'丸子','Title':'','Href':'http://i.wanz.im/'}, {'Name':'任平生','Title':'','Href':'http://rpsh.net/'}, {'Name':'葵中剑','Title':'','Href':'http://swordair.com/'}, {'Name':'任寒韬','Title':'','Href':'http://www.css3china.com/'}, {'Name':'99css','Title':'','Href':'http://www.99css.com/'}, {'Name':'秦元培','Title':'','Href':'http://qinyuanpei.com/'}, {'Name':'进步博客','Title':'','Href':'http://www.topcss.org/'}, {'Name':'潘利强','Title':'','Href':'http://www.plqblog.com/views/index.php'}, {'Name':'豪情','Title':'','Href':'http://www.cnblogs.com/jikey/',\"New\":\"1\"}, {'Name':'gameKnife','Title':'','Href':'http://gameknife.github.io/'}, {'Name':'jiayx','Title':'','Href':'https://jiayx.net/'}, {'Name':'libhappy','Title':'','Href':'http://libhappy.com/'}, {'Name':'moxfive','Title':'','Href':'http://moxfive.xyz/'}, {'Name':'al0n4k','Title':'','Href':'http://al0n4k.com/'}, {'Name':'淡忘~浅思','Title':'','Href':'http://www.ido321.com/'}, {'Name':'zipperary','Title':'','Href':'http://zipperary.com/'}, {'Name':'Xuanwo','Title':'','Href':'https://xuanwo.org/'}, {'Name':'索凌网络','Title':'','Href':'http://suoling.net/'}, {'Name':'罗礼权','Title':'','Href':'http://heeroluo.net/'}, {'Name':'keenwon','Title':'','Href':'http://www.flqin.com/'}, {'Name':'赵柯宇','Title':'','Href':'http://keenwon.com/'}, {'Name':'heero','Title':'','Href':'http://dengo.org/'}, {'Name':'MOxFIVE','Title':'','Href':'http://MOxFIVE.github.io/'}, {'Name':'heeroluo','Title':'','Href':'http://heeroluo.net/'}, {'Name':'DoubleV','Title':'','Href':'http://www.vsay.cn/'}, {'Name':'兮兮','Title':'','Href':'http://www.ccwebsite.com/'}, {'Name':'翁天信','Title':'','Href':'http://blog.dandyweng.com/'}, {'Name':'潘利强','Title':'','Href':'http://www.plqblog.com/views/index.php'}, {'Name':'PuYart','Title':'','Href':'http://puyart.net/'}, {'Name':'coverr','Title':'','Href':'http://www.coverr.co/'}, {'Name':'阮一峰','Title':'','Href':'http://www.ruanyifeng.com/home.html'}, {'Name':'零度逍遥','Title':'一位热爱前端开发的码农，喜欢研究一些新鲜的事物，希望结交志趣相投的朋友','Href':'http://www.lingdublog.com/'}, {'Name':'勾三股四','Title':'就职于傲游','Href':'http://jiongks.name/'}, {'Name':'玉伯(lifesinger)','Title':'就职于淘宝','Href':'http://lifesinger.wordpress.com/'}, {'Name':'hankin技术宅','Title':'hankin技术宅','Href':'http://www.hankin.cn/'}, {'Name':'蘇陽誌','Title':'給時光以生命','Href':'http://www.yloveq.com/'}, {'Name':'罗磊','Title':'在每一个美好的思想前停留','Href':'https://luolei.org/'}, {'Name':'王鹏飞','Title':'一个立志成为优雅前端工程师的小白','Href':'http://www.chengfeilong.com/'}, {'Name':'DBPOO','Title':'总之是个忙碌于钢铁混泥土中的上班族。','Href':'http://www.dbpoo.com/'}, {'Name':'迷渡','Title':'专注最时髦的web开发技术','Href':'http://justjavac.com/'}, {'Name':'Sofish','Title':'目前作为一名工程师，在饿了么处理一些关于前端的事情。','Href':'https://sofi.sh/'}, {'Name':'西道の狗窝','Title':'君と見た世界','Href':'https://blog.cdog.me/'}, {'Name':'郑敏','Title':'我喜欢编码，对技术有狂热的激情，最近再研究前端领域的技术。','Href':'http://codinglife.in/'}, {'Name':'小胡子哥','Title':'My name is Lee Jing(李靖). You can call me Barret. I was born in 1992.','Href':'http://www.barretlee.com/'}, {'Name':'卜卜口の','Title':'九四年生热爱前端/拍照/涂鸦/轮滑的单身少年','Href':'http://mouto.org/'}, {'Name':'简易工作室','Title':'以AutoIT v3 为主的个人博客，技术控！欢迎Au3爱好者一起交流','Href':'http://www.jianyiit.com/'}, {'Name':'樂天笔记','Title':'','Href':'http://www.letiantian.me/'}, {'Name':'钱魏','Title':'现就职于一家OTA，做过营销，做过产品，做过技术，做过数据。','Href':'http://www.biaodianfu.com/'}, {'Name':'LiNPX','Title':'闲着写点简单的分享','Href':'https://www.linpx.com/'}, {'Name':'Waterstrong','Title':'I’m Waterstrong! The man who has made up his mind to win will never say “Impossible”!','Href':'http://blog.waterstrong.me/'}, {'Name':'西门的后花园','Title':'一个热爱网络的年轻人的博客','Href':'http://ons.me/'}, {'Name':'Zohars Blog','Title':'没什么好说的，一个不明事理的初中狗。','Href':'https://www.iwch.me/'}, {'Name':'H E A V E N','Title':'','Href':'http://isayme.github.io/'}, {'Name':'林土晓','Title':'念念不忘，必有回响','Href':'http://www.arao.me/'}, {'Name':'灵感的小窝','Title':'生活琐碎、前端杂谈、诗情画意、随心笔记','Href':'http://ideazhao.com/'}, {'Name':'彬Go','Title':'就职于人人','Href':'http://blog.bingo929.com/'}, {'Name':'Jeanne','Title':'就职于腾讯','Href':'http://csshouse.net/'}, {'Name':'smallni','Title':'就职于携程','Href':'http://www.smallni.com/'}, {'Name':'李成银','Title':'就职于百度','Href':'http://www.welefen.com/'}, {'Name':'搁浅被注册了','Title':'前端水深，光会游泳可不够，狗爬式也有出头天。','Href':'http://www.sheyilin.com/'}, {'Name':'编程随想的博客','Title':'我也会有恐惧和贪婪, 只不过是在大众贪婪时恐惧, 在大众恐惧时贪婪!','Href':'https://program-think.blogspot.com/'}, {'Name':'Coderge','Title':'GE, 有态度的coder','Href':'http://coderge.top/'}, {'Name':'Nick Chang','Title':'出发之前永远是梦想 上路之后永远是挑战','Href':''}, {'Name':'Clay Blog','Title':'','Href':'http://nickgo.me/'}, {'Name':'pigeon','Title':'','Href':'http://zhangnai.xin/'}, {'Name':'Bob.Chen','Title':'Pythoner,Web Developer','Href':'http://www.imbeta.cn/'}, {'Name':'Jerry Qu','Title':'专注 WEB 端开发','Href':'https://imququ.com/'}, {'Name':'胡博靖','Title':'小清新的工科女旅程 为中华之崛起而读书','Href':'http://hubojing.github.io/'}, {'Name':'前端小武的博客','Title':'hi, 我是 前端小武，曾用名谢亮，91年（阳历）后... 目前任职于某公司，住在北京昌平史各庄，常活跃于海淀西二旗。','Href':'https://xuexb.com'}, {'Name':'我的小树林','Title':'褪一分浮躁，守一分宁静，握一份真诚，携一份善良，简单程序员。。。 专注于webGIS、dojo、Node.js欢迎各位道友前来论道','Href':'http://www.cnblogs.com/dojo-lzz/'}, {'Name':'前端狗','Title':'','Href':'http://www.fedog.me/'}, {'Name':'lxiongh Blog','Title':'','Href':'http://lxiongh.com/'}, {'Name':'小撸','Title':'博客中所有的文章都是原创的，现在坚持自己写东西的朋友越来越少了，大家都是转发文章。 个人不是很喜欢转发，对于阅读到的信息都应该带有自己的理解，知道每个人的理解不一样的地方很有趣。','Href':'http://www.60sky.com/'}, {'Name':'Tumars','Title':'90后前端开发小青年，正在前途未卜的码农不归路上一路狂奔。','Href':'http://www.ferecord.com/'}, {'Name':'MARKSZのBlog','Title':'Do what you love,Love what you do','Href':'http://molunerfinn.com/'}, {'Name':'木木木木木','Title':'不问明天，悠然浪费','Href':'https://immmmm.com/'}, {'Name':'晚晴幽草轩轩主','Title':'您能来到这里，实在令人欢喜；这昭示于茫茫人海中：我们算是有了一段缘起；这本身就不是一件易事儿。','Href':'http://www.jeffjade.com/'}, {'Name':'xts.so','Title':'分享技术相关的文章','Href':'https://xts.so/'}, {'Name':'qfdk','Title':'时光荏苒，岁月穿梭。','Href':'http://blog.qfdk.me/'}, {'Name':'微日记','Title':'','Href':'http://www.jackpu.com/'}, {'Name':'BUG研发中心','Title':'','Href':'https://unnamed42.github.io/'}, {'Name':'MrZhang','Title':'Web Developer & Designer','Href':'http://mrzhang123.github.io/'}, // {'Name':'','Title':'','Href':''}, // {'Name':'蜜蜂的蜂窝','Title':'手残的自虐之路','Href':'http://vikk.xyz/'}, // {'Name':'Kejun','Title':'就职于豆瓣','Href':'http://hikejun.com/'}, // {'Name':'Donkey(倔倔)','Title':'就职于豆瓣','Href':'http://imdonkey.com/'}, // {'Name':'蒙晨(波希米亚)','Title':'就职于豆瓣','Href':'http://blog.b3inside.com/'}, // {'Name':'greengnn(老卡)','Title':'就职于豆瓣','Href':'http://www.cnblogs.com/greengnn/'}, // {'Name':'糖伴西红柿','Title':'就职于豆瓣','Href':'http://www.gaowhen.com/'}, // {'Name':'Fenng','Title':'曾就职于支付宝','Href':'http://www.dbanotes.net/'}, // {'Name':'sofish','Title':'就职于支付宝','Href':'http://sofish.de/'}, // {'Name':'白鸦','Title':'就职于支付宝','Href':'http://uicom.net/blog/'}, // {'Name':'62mm','Title':'就职于支付宝','Href':'http://www.62mm.net/'}, // {'Name':'伯约(老鱼)','Title':'就职于支付宝','Href':'http://www.ioldfish.cn/'}, // {'Name':'怿飞(圆心,Blank)','Title':'就职于淘宝','Href':'http://www.planabc.net/'}, // {'Name':'明城(mingcheng)','Title':'就职于淘宝','Href':'http://www.gracecode.com/'}, // {'Name':'Der(崇志)','Title':'就职于淘宝','Href':'http://www.ueder.net/'}, // {'Name':'黑妞HAHA','Title':'就职于淘宝','Href':'http://heiniuhaha.cnblogs.com/'}, // {'Name':'飞长','Title':'就职于淘宝','Href':'http://www.veryued.org/'}, // {'Name':'Vilic','Title':'曾实习于淘宝(很有前途的90后)','Href':'http://www.vilic.info/blog/'}, // {'Name':'秦歌(Kaven)','Title':'就职于口碑网','Href':'http://dancewithnet.com/'}, // {'Name':'Emu(Stone)','Title':'就职于腾讯','Href':'http://blog.csdn.net/emu'}, // {'Name':'Ghost','Title':'就职于腾讯','Href':'http://www.cssforest.org/blog/'}, // {'Name':'Yuguo','Title':'就职于腾讯','Href':'http://yuguo.us/weblog/'}, // {'Name':'臭鱼','Title':'曾就职于腾讯','Href':'http://www.chouyu.com.cn/'}, // {'Name':'艾文王','Title':'就职于腾讯','Href':'http://blog.ivane.me/'}, // {'Name':'Danger','Title':'就职于腾讯','Href':'http://www.dengjie.com/'}, // {'Name':'屈超','Title':'就职于腾讯','Href':'http://www.quchao.com/'}, // {'Name':'米随随','Title':'就职于腾讯','Href':'http://s5s5.me/'}, // {'Name':'大猫','Title':'就职于腾讯','Href':'http://ooxx.me/'}, // {'Name':'AVENIR(郑焕义)','Title':'就职于腾讯','Href':'http://caib.me/'}, // {'Name':'OnLing','Title':'就职于腾讯','Href':'http://www.onling.net/blog/'}, // {'Name':'Xiaoxiao','Title':'就职于腾讯','Href':'http://liuyuntian.com/'}, // {'Name':'小李刀刀','Title':'就职于腾讯','Href':'http://ofcss.com/'}, // {'Name':'kent.zhu','Title':'就职于百度','Href':'http://www.ikent.me/blog/'}, // {'Name':'aoao(嗷嗷)','Title':'就职于百度','Href':'http://www.aoao.org.cn/'}, // {'Name':'JerryQu','Title':'就职于百度','Href':'http://www.imququ.com/'}, // {'Name':'5key','Title':'就职于阿里巴巴','Href':'http://5key.net/'}, // {'Name':'yaohaixiao','Title':'就职于阿里巴巴','Href':'http://www.yaohaixiao.com/'}, // Android {'Name':'方杰','Title':'就职于赶集','Href':'http://fangjie.info/',\"New\":\"1\"}, {'Name':'IsNine','Title':'一只向往旅行的程序员','Href':'http://www.isnine.me'}, {'Name':'Qiuncheng','Title':'每一秒我们都有机会让下一秒变得更好！','Href':'http://qiuncheng.com/'}, {'Name':'天猫前端','Title':'keep calm and carry on!','Href':'http://tmallfe.github.io/'}, {'Name':'coney','Title':'有些事情,再不去做就忘了.有些人,再不去找就没了.','Href':'http://gengbiao.me/'}, {'Name':'Yanzai','Title':'从 WordPress 迁过来,正在改版中,因为很懒,或许要改个十年八年...','Href':'http://yanzai.me/'}, // {'Name':'','Title':'','Href':''}, // PHP {'Name':'风雅颂','Title':'我们在黑暗中掘地洞之余，一定要努力化眼泪为知识。','Href':'http://xferris.me/',\"New\":\"1\"}, ] },{ \"pageT2\":\"国外博客\", \"pageC2\":[ {'Name':'bennettfeely','Title':'Hello! My name is Bennett Feely.I make websites so you dont have to.','Href':'http://bennettfeely.com/'}, {'Name':'Vincent Voyer','Title':'我是一个专业从事Node.js法国JavaScript开发者，自动化测试和部署。','Href':'http://www.function.fr/'}, {'Name':'STRML','Title':'国外STRML技术Bolg','Href':'http://blog.strml.net/'}, {'Name':'SteveSouders','Title':'谷歌工程师Steve Souders\"','Href':'http://www.stevesouders.com/blog/'}, {'Name':'JohnResig','Title':'jQuery作者John Resig\"','Href':'http://ejohn.org/'}, {'Name':'DouglasCrockford','Title':'JSLint 作者，《语言精粹》作者\"','Href':'http://javascript.crockford.com/'}, {'Name':'EricMeyer','Title':'CSS WEB标准专家\"','Href':'http://meyerweb.com/'}, {'Name':'NicholasZakas','Title':'《高性能JavaScript》作者\"','Href':'http://www.nczonline.net/'}, {'Name':'Addy Osmani','Title':'《Learning JavaScript Design Patterns 》作者\"','Href':'http://addyosmani.com/'}, ] }], }], }"}],"posts":[{"title":"redis常用命令总结","slug":"redis常用命令总结","date":"2018-05-24T07:26:22.000Z","updated":"2018-05-24T07:29:53.000Z","comments":true,"path":"2018/05/24/redis常用命令总结/","link":"","permalink":"http://jiaxf.github.io/2018/05/24/redis常用命令总结/","excerpt":"","text":"redis常用命令总结一、key pattern 查询相应的key （1）redis允许模糊查询key 有3个通配符 *、?、[]` （2）randomkey：返回随机key （3）type key：返回key存储的类型 （4）exists key：判断某个key是否存在 （5）del key：删除key （6）rename key newkey：改名 （7）renamenx key newkey：如果newkey不存在则修改成功 （8）move key 1：将key移动到1数据库 （9）ttl key：查询key的生命周期（秒） （10）expire key 整数值：设置key的生命周期以秒为单位 （11）pexpire key 整数值：设置key的生命周期以毫秒为单位 （12）pttl key：查询key 的生命周期（毫秒） （13）perisist key：把指定key设置为永久有效 二、字符串类型的操作 （1）set key value [ex 秒数] [px 毫秒数] [nx/xx] 如果ex和px同时写，则以后面的有效期为准 nx：如果key不存在则建立 xx：如果key存在则修改其值 （2）get key：取值 （3）mset key1 value1 key2 value2 一次设置多个值 （4）mget key1 key2 ：一次获取多个值 （5）setrange key offset value：把字符串的offset偏移字节改成value 如果偏移量 &gt; 字符串长度，该字符自动补0x00 （6）append key value ：把value追加到key 的原值上 （7）getrange key start stop：获取字符串中[start, stop]范围的值 对于字符串的下标，左数从0开始，右数从-1开始 注意：当start&gt;length，则返回空字符串 当stop&gt;=length，则截取至字符串尾 如果start所处位置在stop右边，则返回空字符串 （8）getset key nrevalue：获取并返回旧值，在设置新值 （9）incr key：自增，返回新值，如果incr一个不是int的value则返回错误，incr一个不存在的key，则设置key为1 （10）incrby key 2：跳2自增 （11）incrbyfloat by 0.7： 自增浮点数 （12）setbit key offset value：设置offset对应二进制上的值，返回该位上的旧值 注意：如果offset过大，则会在中间填充0 offset最大到多少 2^32-1，即可推出最大的字符串为512M （13）bitop operation destkey key1 [key2..] 对key1 key2做opecation并将结果保存在destkey上 opecation可以是AND OR NOT XOR （14）strlen key：取指定key的value值的长度 （15）setex key time value：设置key对应的值value，并设置有效期为time秒 三、链表操作 Redis的list类型其实就是一个每个子元素都是string类型的双向链表，链表的最大长度是2^32。list既可以用做栈，也可以用做队列。 list的pop操作还有阻塞版本，主要是为了避免轮询 （1）lpush key value：把值插入到链表头部 （2）rpush key value：把值插入到链表尾部 （3）lpop key ：返回并删除链表头部元素 （4）rpop key： 返回并删除链表尾部元素 （5）lrange key start stop：返回链表中[start, stop]中的元素 （6）lrem key count value：从链表中删除value值，删除count的绝对值个value后结束 count &gt; 0 从表头删除 count &lt; 0 从表尾删除 count=0 全部删除 （7）ltrim key start stop：剪切key对应的链接，切[start, stop]一段并把改制重新赋给key （8）lindex key index：返回index索引上的值 （9）llen key：计算链表的元素个数 （10）linsert key after|before search value：在key 链表中寻找search，并在search值之前|之后插入value （11）rpoplpush source dest：把source 的末尾拿出，放到dest头部，并返回单元值 应用场景： task + bak 双链表完成安全队列 业务逻辑： rpoplpush task bak 接收返回值并做业务处理 如果成功则rpop bak清除任务，如果不成功，下次从bak表取任务 （12）brpop，blpop key timeout：等待弹出key的尾/头元素 timeout为等待超时时间，如果timeout为0则一直等待下去 应用场景：长轮询ajax，在线聊天时能用到 四、hashes类型及操作 Redis hash 是一个string类型的field和value的映射表，它的添加、删除操作都是O(1)（平均）。hash特别适用于存储对象，将一个对象存储在hash类型中会占用更少的内存，并且可以方便的存取整个对象。 配置： hash_max_zipmap_entries 64 #配置字段最多64个 hash_max_zipmap_value 512 #配置value最大为512字节 （1）hset myhash field value：设置myhash的field为value （2）hsetnx myhash field value：不存在的情况下设置myhash的field为value （3）hmset myhash field1 value1 field2 value2：同时设置多个field （4）hget myhash field：获取指定的hash field （5）hmget myhash field1 field2：一次获取多个field （6）hincrby myhash field 5：指定的hash field加上给定的值 （7）hexists myhash field：测试指定的field是否存在 （8）hlen myhash：返回hash的field数量 （9）hdel myhash field：删除指定的field （10）hkeys myhash：返回hash所有的field （11）hvals myhash：返回hash所有的value （12）hgetall myhash：获取某个hash中全部的field及value ## 五、集合结构操作 特点：无序性、确定性、唯一性 （1）sadd key value1 value2：往集合里面添加元素 （2）smembers key：获取集合所有的元素 （3）srem key value：删除集合某个元素 （4）spop key：返回并删除集合中1个随机元素（可以坐抽奖，不会重复抽到某人） （5）srandmember key：随机取一个元素 （6）sismember key value：判断集合是否有某个值 （7）scard key：返回集合元素的个数 （8）smove source dest value：把source的value移动到dest集合中 （9）sinter key1 key2 key3：求key1 key2 key3的交集 （10）sunion key1 key2：求key1 key2 的并集 （11）sdiff key1 key2：求key1 key2的差集 （12）sinterstore res key1 key2：求key1 key2的交集并存在res里 六、有序集合 概念：它是在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动按新的值调整顺序。可以理解为有两列的mysql表，一列存储value，一列存储顺序，操作中key理解为zset的名字。 和set一样sorted，sets也是string类型元素的集合，不同的是每个元素都会关联一个double型的score。sorted set的实现是skip list和hash table的混合体。 当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是O(1)。另一个score到元素的映射被添加的skip list，并按照score排序，所以就可以有序地获取集合中的元素。添加、删除操作开销都是O(logN)和skip list的开销一致，redis的skip list 实现是双向链表，这样就可以逆序从尾部去元素。sorted set最经常使用方式应该就是作为索引来使用，我们可以把要排序的字段作为score存储，对象的ID当元素存储。 （1）zadd key score1 value1：添加元素 （2）zrange key start stop [withscore]：把集合排序后,返回名次[start,stop]的元素 默认是升续排列 withscores 是把score也打印出来 （3）zrank key member：查询member的排名（升序0名开始） （4）zrangebyscore key min max [withscores] limit offset N：集合（升序）排序后取score在[min, max]内的元素，并跳过offset个，取出N个 （5）zrevrank key member：查询member排名（降序 0名开始） （6）zremrangebyscore key min max：按照score来删除元素，删除score在[min, max]之间 （7）zrem key value1 value2：删除集合中的元素 （8）zremrangebyrank key start end：按排名删除元素，删除名次在[start, end]之间的 （9）zcard key：返回集合元素的个数 （10）zcount key min max：返回[min, max]区间内元素数量 （11）zinterstore dest numkeys key1[key2..] [WEIGHTS weight1 [weight2…]] [AGGREGATE SUM|MIN|MAX] 求key1，key2的交集，key1，key2的权值分别是weight1，weight2 聚合方法用 sum|min|max 聚合结果 保存子dest集合内 注意：weights,aggregate如何理解？ 答：如果有交集，交集元素又有score，score怎么处理？aggregate num-&gt;score相加，min最小score，max最大score，另外可以通过weights设置不同的key的权重，交集时 score*weight 七、服务器相关命令 （1）ping：测定连接是否存活 （2）echo：在命令行打印一些内容 （3）select：选择数据库 （4）quit：退出连接 （5）dbsize：返回当前数据库中key的数目 （6）info：获取服务器的信息和统计 （7）monitor：实时转储收到的请求 （8）config get 配置项：获取服务器配置的信息 config set 配置项 值：设置配置项信息 （9）flushdb：删除当前选择数据库中所有的key （10）flushall：删除所有数据库中的所有的key （11）time：显示服务器时间，时间戳（秒），微秒数 （12）bgrewriteaof：后台保存rdb快照 （13）bgsave：后台保存rdb快照 （14）save：保存rdb快照 （15）lastsave：上次保存时间 （16）shutdown [save/nosave] 注意：如果不小心运行了flushall，立即shutdown nosave，关闭服务器，然后手工编辑aof文件，去掉文件中的flushall相关行，然后开启服务器，就可以倒回原来是数据。如果flushall之后，系统恰好bgwriteaof了，那么aof就清空了，数据丢失。 （17）showlog：显示慢查询 问：多慢才叫慢？ 答：由slowlog-log-slower-than 10000，来指定（单位为微秒） 问：服务器存储多少条慢查询记录 答：由slowlog-max-len 128，来做限制","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://jiaxf.github.io/tags/缓存/"}]},{"title":"redis通配符删除","slug":"redis通配符删除","date":"2018-05-24T07:14:45.000Z","updated":"2018-05-24T07:20:32.000Z","comments":true,"path":"2018/05/24/redis通配符删除/","link":"","permalink":"http://jiaxf.github.io/2018/05/24/redis通配符删除/","excerpt":"","text":"redis通配符删除批量删除KeyRedis 中有删除单个 Key 的指令 DEL，但好像没有批量删除 Key 的指令，不过我们可以借助 Linux 的 xargs 指令来完成这个动作 1redis-cli keys \"*\" | xargs redis-cli del 12345//如果要指定 Redis 数据库访问密码，使用下面的命令redis-cli -a password keys \"*\" | xargs redis-cli -a password del //下面的命令指定数据序号为0，即默认数据库 redis-cli -n 0 keys \"*\" | xargs redis-cli -n 0 del 1234//批量删除redis 数据库中redis key的方法如下：bin/redis-cli –h &lt;your_redis_server_IP&gt; -p 6379 -n &lt;your database ID&gt; -a &lt;your_auth_keys&gt; keys \"mykeys*\" | xargs bin/redis-cli -n &lt;your database ID&gt; del 12345//删除所有Key，可以使用Redis的flushdb和flushall命令//删除当前数据库中的所有Key flushdb //删除所有数据库中的key flushall","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://jiaxf.github.io/tags/缓存/"}]},{"title":"程序猿灯谜","slug":"程序猿灯谜","date":"2018-05-04T08:24:04.000Z","updated":"2018-05-04T09:04:08.000Z","comments":true,"path":"2018/05/04/程序猿灯谜/","link":"","permalink":"http://jiaxf.github.io/2018/05/04/程序猿灯谜/","excerpt":"灯谜 老会计喝二锅（打一热门技术） 梦中交谈（打一热门技术） 连胜六场又赢了（打一知名操作系统） 小米大合唱（打一著名互联网厂商） 男女生都一样（打一技术术语） 不达目的誓不罢休（打一著名网络解决方案提供商） 席卷天下，包举宇内，囊括四海，并吞八荒（打一互联网技术） 话又说回来了（打一网络安全术语） 禽流感（打一常见的PC/服务器故障） 深夜造访（打一网络安全术语） 屡屡破记录（打一技术术语） 单个花生超产（打一芯片技术） 驴友上路多郁闷（打一网络设备） 月老难扯二人姻缘（打一网络技术） 光芒照四方（打一安全厂商） 网管抓狂（打一网络设备） 悟空出了五指山（打一技术术语） 不听话就得打（打一网络安全术语） 整个界面都是阿凡达（打一PC/服务器故障现象） E（打一开发语言） 拳王的金腰带（打一网络技术） 方便月老配对象（打一网络设备） 走麦城（打一网络安全设备） 皇帝绷着脸（打一设备） 太上老君的金丹（打一网络安全术语） 王老吉面壁（打一网络安全设备）","text":"灯谜 老会计喝二锅（打一热门技术） 梦中交谈（打一热门技术） 连胜六场又赢了（打一知名操作系统） 小米大合唱（打一著名互联网厂商） 男女生都一样（打一技术术语） 不达目的誓不罢休（打一著名网络解决方案提供商） 席卷天下，包举宇内，囊括四海，并吞八荒（打一互联网技术） 话又说回来了（打一网络安全术语） 禽流感（打一常见的PC/服务器故障） 深夜造访（打一网络安全术语） 屡屡破记录（打一技术术语） 单个花生超产（打一芯片技术） 驴友上路多郁闷（打一网络设备） 月老难扯二人姻缘（打一网络技术） 光芒照四方（打一安全厂商） 网管抓狂（打一网络设备） 悟空出了五指山（打一技术术语） 不听话就得打（打一网络安全术语） 整个界面都是阿凡达（打一PC/服务器故障现象） E（打一开发语言） 拳王的金腰带（打一网络技术） 方便月老配对象（打一网络设备） 走麦城（打一网络安全设备） 皇帝绷着脸（打一设备） 太上老君的金丹（打一网络安全术语） 王老吉面壁（打一网络安全设备） 谜底 老会计喝二锅（打一热门技术）—— 云计算 梦中交谈（打一热门技术）—— 虚拟化 连胜六场又赢了（打一知名操作系统）—— Win7 小米大合唱（打一著名互联网厂商）—— 谷歌 男女生都一样（打一技术术语）—— 兼容性 不达目的誓不罢休（打一著名网络解决方案提供商）—— 思科 席卷天下，包举宇内，囊括四海，并吞八荒（打一互联网技术）—— 广域网 话又说回来了（打一网络安全术语） —— 循环语句 禽流感（打一常见的PC/服务器故障）—— 死机 深夜造访（打一网络安全术语） —— 黑客 屡屡破记录（打一技术术语）—— 超频 单个花生超产（打一芯片技术） —— 多核 驴友上路多郁闷（打一网络设备）—— 路由器 月老难扯二人姻缘（打一网络技术）—— 无线 光芒照四方（打一安全厂商）—— 金山 网管抓狂（打一网络设备）—— 网卡 悟空出了五指山（打一技术术语）—— 解压 不听话就得打（打一网络安全术语）—— 拒绝服务攻击 整个界面都是阿凡达（打一PC/服务器故障现象）—— 蓝屏 E（打一开发语言）—— C++ 拳王的金腰带（打一网络技术）—— 宽带 方便月老配对象（打一网络设备）—— 集线器 走麦城（打一网络安全设备）—— 网关 皇帝绷着脸（打一设备）—— 主板 太上老君的金丹（打一网络安全术语）—— 密钥 王老吉面壁（打一网络安全设备）—— 防火墙","categories":[],"tags":[{"name":"生活乐趣","slug":"生活乐趣","permalink":"http://jiaxf.github.io/tags/生活乐趣/"}]},{"title":"高性能web平台OpenResty","slug":"高性能web平台OpenResty","date":"2018-05-04T06:38:17.000Z","updated":"2018-05-04T08:15:55.000Z","comments":true,"path":"2018/05/04/高性能web平台OpenResty/","link":"","permalink":"http://jiaxf.github.io/2018/05/04/高性能web平台OpenResty/","excerpt":"","text":"高性能web平台OpenRestyOpenResty®OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。 OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。 OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。 OpenResty(又称：ngx_openresty) 是一个基于 NGINX 的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以 快速构造出足以胜任 10K 以上并发连接响应的超高性能 Web 应用系统。 下载安装macOS/Mac OS X强烈建议 Mac OS X 或者 macOS 系统用户通过 homebrew 包管理器安装 OpenResty，像下面这样： 12brew tap openresty/brewbrew install openresty 如果你之前是从 homebrew/nginx 安装的 OpenResty，请先执行： 1brew untap homebrew/nginx Hello World实例安装成功后，可以使用openresty直接输出html页面。首先可以创建一个工作目录123mkdir /home/wwwcd /home/www/mkdir logs/ conf/ 其中，logs目录用于存放日志，conf用于存放配置文件。 在conf目录下创建一个nginx.conf文件 代码如下： 12345678910111213141516worker_processes 1;error_log logs/error.log;events &#123; worker_connections 1024;&#125;http &#123; server &#123; listen 9000; location / &#123; default_type text/html; content_by_lua ' ngx.say(\"&lt;p&gt;Hello, World!&lt;/p&gt;\") '; &#125; &#125;&#125; 启动openresty默认情况下 openresty 安装在 /usr/local/openresty 目录中，启动命令为:12cd /home/www/usr/local/openresty/nginx/sbin/nginx -p `pwd`/ -c conf/nginx.conf 如果没有任何输出，说明启动成功，-p 指定我们的项目目录，-c 指定配置文件。 接下来我们可以使用 curl 来测试是否能够正常范围： curl http://localhost:9000/ 输出结果为： &lt;p&gt;Hello, World!&lt;/p&gt; OpenResty 的目标是让你的 Web 服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I/O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL,PostgreSQL,~Memcaches 以及 ~Redis 等都进行一致的高性能响应。所以对于一些高性能的服务来说，可以直接使用 OpenResty 访问 Mysql或Redis等，而不需要通过第三方语言（PHP、Python、Ruby）等来访问数据库再返回，这大大提高了应用的性能。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"服务器","slug":"服务器","permalink":"http://jiaxf.github.io/tags/服务器/"}]},{"title":"对称加密&非对称加密","slug":"对称加密&非对称加密","date":"2018-05-03T01:27:09.000Z","updated":"2018-05-03T02:17:25.000Z","comments":true,"path":"2018/05/03/对称加密&非对称加密/","link":"","permalink":"http://jiaxf.github.io/2018/05/03/对称加密&非对称加密/","excerpt":"","text":"对称加密 - DES 真正的加密算法，带密钥，加密和解密使用相同的密钥 对称加密优点是算法公开、计算量小、加密速度快、加密效率高 双方都保存秘钥，其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担 DES使用56位密钥，以现代计算能力，24小时内即可被破解。虽然如此，在某些简单应用中，我们还是可以使用DES加密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DES &#123; /** * 加密 * * @param datasource byte[] * @param password String * @return byte[] */ public static byte[] encrypt(byte[] datasource, String password) &#123; try &#123; SecureRandom random = new SecureRandom(); DESKeySpec desKey = new DESKeySpec(password.getBytes()); //创建一个密匙工厂，然后用它把DESKeySpec转换成 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\"); SecretKey securekey = keyFactory.generateSecret(desKey); //Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(\"DES\"); //用密匙初始化Cipher对象,Cipher.ENCRYPT_MODE代表编码模式 cipher.init(Cipher.ENCRYPT_MODE, securekey, random); //现在，获取数据并加密 //正式执行加密操作 return cipher.doFinal(datasource); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 解密 * * @param src byte[] * @param password String * @return byte[] * @throws Exception */ public static byte[] decrypt(byte[] src, String password) throws Exception &#123; // DES算法要求有一个可信任的随机数源 SecureRandom random = new SecureRandom(); // 创建一个DESKeySpec对象 DESKeySpec desKey = new DESKeySpec(password.getBytes()); // 创建一个密匙工厂 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\"); // 将DESKeySpec对象转换成SecretKey对象 SecretKey securekey = keyFactory.generateSecret(desKey); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(\"DES\"); // 用密匙初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, random); // 真正开始解密操作 return cipher.doFinal(src); &#125; &#125; 非对称加密 - RSA1、用RSA算法生成一对密钥，公钥发放给外部客户，私钥自己保管；有以下应用场景： 【公钥加密、私钥解密】或者【私钥签名、公钥验证】2、非对称加解密的理解： 小明想秘密给小英发送消息 小英手里有一个盒子（public key），这个盒子只有小英手里的钥匙（private key）才打得开 小英把盒子送给小明（分发公钥） 小明写好消息放进盒子里，锁上盒子（公钥加密） 小明把盒子寄给小英（密文传输） 小英用手里的钥匙打开盒子，得到小明的消息（私钥解密） 假设小刚劫持了盒子，因为没有小英的钥匙，他也打不开 与DES不同，RSA算法中，每个通信主体都有两个钥匙，一个公钥一个私钥。就是有2把钥匙 使用publicKey可以对数据进行加密 使用Key才能对数据进行解密 单方向传输用公钥加密的数据，只有私钥能解开（可用于加密）；同时，使用私钥加密的数据，只有公钥能解开（签名）。但是速度很慢（比私钥加密慢100到1000倍），公钥的主要算法有RSA，还包括Blowfish,Diffie-Helman等。 公钥与私钥 权威数字认证机构（CA）给所有通信主体（个人或组织）颁发公钥和私钥，彼此配对，分别唯一。 私钥好比数字指纹，同时具有解密和加密功能。个人保管，不公开。 公钥好比安全性极高的挂号信箱地址，公开。 公私钥加解密举例 设若甲有一份需保密的数字商业合同发给乙签署。经过如下步骤： 甲用乙的公钥对合同加密。 密文从甲发送到乙。 乙收到密文，并用自己的私钥对其解密。 解密正确，经阅读，乙用自己的私钥对合同进行签署。 乙用甲的公钥对已经签署的合同进行加密。 乙将密文发给甲。 甲用自己的私钥将已签署合同解密。 解密正确，确认签署。 公私钥加解密说明从以上步骤，我们知道： 用公钥加密的密文能且只能用与其唯一配对的私钥才能解开。 如果某份密文被解开，那么肯定是密文的目标信息主体解开的。 私钥因其唯一标识所有者的属性，被用于数字签名，具有法律效力。 一。 公私钥生成 随机选定两个大素数p, q. 计算公钥和私钥的公共模数 n = pq . 计算模数n的欧拉函数 φ(n) . 选定一个正整数e, 使1 &lt; e &lt; φ(n) , 且e与φ(n)互质. 计算d, 满足 de ≡ 1 (mod φ(n) ), (k为某个正整数).6.n与e决定公钥, n与d决定私钥. 二。加解密该过程为小张给小李发消息，公钥为小李的公钥(n &amp; e), 私钥为小李的私钥(n &amp; d). 小张欲给小李发一个消息M, 他先把M转换为一个大数m &lt; n, 然后用小李的公钥(n &amp; e)把m加密为另一个大数:c = me mod n 小李收到小张发来的大数c, 着手解密. 通过自己的私钥(n &amp; d), 得到原来的大数m:m = cd mod n3.再把m转换为M, 小李即得到小张的原始消息. 这个过程之所以能通过, 是因为有如下等式: cd ≡(me)d ≡med (mod n) 参考 编码和加密算法的使用（MD5、Base64、DES、RSA）","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"加密","slug":"加密","permalink":"http://jiaxf.github.io/tags/加密/"},{"name":"解密","slug":"解密","permalink":"http://jiaxf.github.io/tags/解密/"},{"name":"算法","slug":"算法","permalink":"http://jiaxf.github.io/tags/算法/"}]},{"title":"MD5、SHA1、HMAC、HMAC_SHA1区别","slug":"MD5、SHA1、HMAC、HMAC_SHA1","date":"2018-05-02T07:43:02.000Z","updated":"2018-05-03T01:16:37.000Z","comments":true,"path":"2018/05/02/MD5、SHA1、HMAC、HMAC_SHA1/","link":"","permalink":"http://jiaxf.github.io/2018/05/02/MD5、SHA1、HMAC、HMAC_SHA1/","excerpt":"","text":"MD5、SHA1、HMAC、HMAC_SHA1区别MD5MD5 – message-digest algorithm 5(信息-摘要算法)缩写，是一种不可逆的加密算法，对任何字符串都可以加密成一段唯一的固定长度的代码。可以是128位。MD5码可以唯一地代码原信息的特征，通常用于密码的加密存储，数字签名，文件完整性验证等。 1234567891011121314/** * MD5加密 * * @param data * @return * @throws Exception */public static byte[] encryptMD5(byte [] data) throws Exception &#123; MessageDigest md5 = MessageDigest.getInstance(KEY_MD5); md5.update(data); return md5.digest();&#125; SHA1SHA(Secure Hash Algorithm,安全散列算法)，较MD5更安全。SHA1是由NISTNSA设计，对长度小于264的输入，产生长度为160bit的散列值，可穷举性(brute-force )更好。SHA-1是由美国标准技术局（NIST）颁布的国家标准，是一种应用最为广泛的Hash函数算法，也是 目前最先进的加密技术，被政府部门和私营业主用来处理敏感信息。也常用于验证文件有没有被篡改。 1234567public static byte[] encryptSHA(byte[] data) throws Exception &#123; MessageDigest sha = MessageDigest.getInstance(KEY_SHA); sha.update(data); return sha.digest();&#125; HMAC_SHA1HMAC是密钥相关的哈希运算消息认证码(Hash-based Message Authentication Code, 散列消息鉴别码),HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生产一个消息摘要作为输出。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC,并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。 HMAC_SHA1需要一个密钥，而SHA1不需要。 1234567891011121314151617181920212223242526272829/** * 初始化HMAC密钥 * * @return * @throws Exception */public static String initMacKey() throws Exception &#123; Keygenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC); SecretKey secretKey = keyGenerator.geterateKey(); return encryptBASE64(secretKey.getEncoded());&#125;/** * HMAC加密 * * @param data * @param key * @return * @throws Exception */public static byte[] encryptHMAC(byte[] data, String key) throws Exception &#123; SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC); Mac mac = Mac.getInstance(secretKey.getAlgorithm()); mac.init(secretKey); return mac.doFinal(data);&#125; CRCCRC的全称为CyclicRedundancyCheck，中文名称为循环冗余校验。它是一类重要的线性分组码，编码和解码方法简单，检错和纠错能力强，在通信领域广泛地用于实现差错控制。 BASE64按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent brbitrary sequences of octets in a form that need not be humamly readable.） 123456789101112131415161718192021/** * BASE64解密 * * @param key * @return * @throws Exception */public static byte[] decryptBASE64(String key) throws Exception &#123; return (new BASE64Decoder()).decodeBuffer(key);&#125;/** * BASE64加密 * * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) throws Exception &#123; return (new BASE64Encoder()).encodeBuffer(key);&#125; ## hash算法的作用 文件校验 MD5Hash算法的“数字指纹”，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5checksum的命令。 数字签名 Hash算法也是现代密码体系中的一个重要组成部分，由于非对称算法的运算速度较慢，所以在数字签名协议中，单项散列函数扮演了一个重要的角色。对Hash值，又称”数字摘要”进行数字签名，在统计上可以任务与对文件本身进行数字签名是等效的。 鉴权协议 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.security.MessageDigest; import javax.crypto.KeyGenerator; import javax.crypto.Mac; import javax.crypto.SecretKey; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; /** * 基础加密组件 * * @author jiaxf * @version 1.0 * @since 1.0 */ public abstract class Coder &#123; public static final String KEY_SHA = \"SHA\"; public static final String KEY_MD5 = \"MD5\"; /** * MAC算法可选以下多种算法 * * &lt;pre&gt; * HmacMD5 * HmacSHA1 * HmacSHA256 * HmacSHA384 * HmacSHA512 * &lt;/pre&gt; */ public static final String KEY_MAC = \"HmacMD5\"; /** * BASE64解密 * * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) throws Exception &#123; return (new BASE64Decoder()).decodeBuffer(key); &#125; /** * BASE64加密 * * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) throws Exception &#123; return (new BASE64Encoder()).encodeBuffer(key); &#125; /** * MD5加密 * * @param data * @return * @throws Exception */ public static byte[] encryptMD5(byte[] data) throws Exception &#123; MessageDigest md5 = MessageDigest.getInstance(KEY_MD5); md5.update(data); return md5.digest(); &#125; /** * SHA加密 * * @param data * @return * @throws Exception */ public static byte[] encryptSHA(byte[] data) throws Exception &#123; MessageDigest sha = MessageDigest.getInstance(KEY_SHA); sha.update(data); return sha.digest(); &#125; /** * 初始化HMAC密钥 * * @return * @throws Exception */ public static String initMacKey() throws Exception &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC); SecretKey secretKey = keyGenerator.generateKey(); return encryptBASE64(secretKey.getEncoded()); &#125; /** * HMAC加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptHMAC(byte[] data, String key) throws Exception &#123; SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC); Mac mac = Mac.getInstance(secretKey.getAlgorithm()); mac.init(secretKey); return mac.doFinal(data); &#125; &#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static org.junit.Assert.*;import org.junit.Test;/** * * @author jiaxf * @version 1.0 * @since 1.0 */ public class CoderTest &#123; @Test public void test() throws Exception &#123; String inputStr = \"简单加密\"; System.err.println(\"原文:/n\" + inputStr); byte[] inputData = inputStr.getBytes(); String code = Coder.encryptBASE64(inputData); System.err.println(\"BASE64加密后:/n\" + code); byte[] output = Coder.decryptBASE64(code); String outputStr = new String(output); System.err.println(\"BASE64解密后:/n\" + outputStr); // 验证BASE64加密解密一致性 assertEquals(inputStr, outputStr); // 验证MD5对于同一内容加密是否一致 assertArrayEquals(Coder.encryptMD5(inputData), Coder .encryptMD5(inputData)); // 验证SHA对于同一内容加密是否一致 assertArrayEquals(Coder.encryptSHA(inputData), Coder .encryptSHA(inputData)); String key = Coder.initMacKey(); System.err.println(\"Mac密钥:/n\" + key); // 验证HMAC对于同一内容，同一密钥加密是否一致 assertArrayEquals(Coder.encryptHMAC(inputData, key), Coder.encryptHMAC( inputData, key)); BigInteger md5 = new BigInteger(Coder.encryptMD5(inputData)); System.err.println(\"MD5:/n\" + md5.toString(16)); BigInteger sha = new BigInteger(Coder.encryptSHA(inputData)); System.err.println(\"SHA:/n\" + sha.toString(32)); BigInteger mac = new BigInteger(Coder.encryptHMAC(inputData, inputStr)); System.err.println(\"HMAC:/n\" + mac.toString(16)); &#125; &#125; 参考 加密算法中BASE64、MD5、SHA、HMAC等之间的区别","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"加密","slug":"加密","permalink":"http://jiaxf.github.io/tags/加密/"},{"name":"解密","slug":"解密","permalink":"http://jiaxf.github.io/tags/解密/"},{"name":"Base64","slug":"Base64","permalink":"http://jiaxf.github.io/tags/Base64/"},{"name":"md5","slug":"md5","permalink":"http://jiaxf.github.io/tags/md5/"},{"name":"算法","slug":"算法","permalink":"http://jiaxf.github.io/tags/算法/"}]},{"title":"2018-05-02-Node.js10和npm6发布","slug":"2018-05-02-Node.js10和npm6发布","date":"2018-05-02T00:54:19.000Z","updated":"2018-05-02T02:05:44.000Z","comments":true,"path":"2018/05/02/2018-05-02-Node.js10和npm6发布/","link":"","permalink":"http://jiaxf.github.io/2018/05/02/2018-05-02-Node.js10和npm6发布/","excerpt":"","text":"Node.js10及npm6发布Node.js 发布最新版本 Node.js 10.0.0，同时，npm 6 也随之发布。据了解，今年 10 月，Node.js 10.x 将成为长期支持版本，该版本专注于稳定性、扩展支持以及为各类应用提供一个可靠稳定的平台。 Node.js 10.x 将是第一个支持 OpenSSL 1.1.0 的版本。该版本配备了 Google V8 6.6 JavaScript 引擎，性能会增强，错误处理和跟踪诊断能力也将会提升。此版本还将推出 Node.js API（N-API），N-API 是一个稳定的 API 模块，它独立于 V8，这样就不会阻碍模块在不重新编译的情况下运行新版本的 Node.js。 关于 N-APIN-API 提高了 Node.js 的 ABI 稳定性，有助于模块的部署和维护。Node.js 10 将 ABI 的稳定模块 API（N-API）作为官方支持的 API 层。N-API 旨在解决当今生态系统中的两个问题，一是降低本地模块的维护成本，二是在升级 Node.js 版本时，降低模块使用者之间的摩擦。 升级到最新的 Node.js 版本后，Node.js 版本之间的模块损坏将不再成为 N-API 模块的问题，这对于开发者和消费者来说都是双赢的。为了提高此功能的实用性，N-API 也将被移植到 Node.js 8.x 和 6.x 中，还包括下一版本。 现代化的加密Node.js 10.x 是第一代支持 OpenSSL 1.1.0 的版本，Node.js 现在能够充分利用由 OpenSSL 团队在代码质量、清理和现代化上提供的服务。 Node.js 现在可以将其加密支持扩展到对称加密算法 ChaCha20 和身份认证算法 Poly1305 上，它们共同构成了现代加密系统，增加了 Node.js 使用“ AEAD ”密码套件的可能性。伴随着最近 TLS 1.3 规范的完成，网络安全迈出了一大步，OpenSSL 团队正准备发布 1.1.1 版本，其主要特性是支持 TLS 1.3，而支持 OpenSSL 1.1.1 的 Node.js 10 将可以轻松实现 API 和 ABI 的稳定升级。 错误处理能力提升Node.js 10.x 在利用错误代码以缓解持续性的错误检验上取得了很好的进展。过去，更改文本里的错误都需要等到 semver 主版本更新后，这也意味着只有等到下一个主版本的 Node.js 才能对错误进行更改，而 Node.js 主版本每六个月发布一次。使用错误代码将可以在不中断应用程序的情况下更新文本。 性能改进最新的 V8 在 Promise、异步生成器和阵列性能（array performance）有了很大的改进，Promise 和异步函数的改进消除了异步函数和 desugarded promise 链之间的隔阂，这有利于提高使用 Node.js 构建的应用程序性能。 诊断跟踪和Post mortem在 Node.js 10 中，新的跟踪事件由 performance API 发布，提高了代码的透明性。此外，它还将引入了新的 API，允许用户在代码运行时按需启用和禁用跟踪事件，从而提高了运行时诊断 Node.js 应用程序问题的灵活性。 Node.js 10.x引入npm6Node.js 10.0.0 附带 npm 5.7.x， 但是，预计在 Node.js 10.x 生命周期的早期会更新为 npm 6。第 6 版将侧重于性能、稳定性和安全性，与先前版本的 npm 相比，性能提高 1700％。以后，如果使用具有已知安全问题的代码，npm Registry 的用户会收到警告通知。npm 将自动检查针对 NSP 数据库的安装请求，并在代码包含漏洞时发出警告通知。 有关npm6的更多信息，可访问https://go.npm.me/npm6 注意： Node.js 10 版本可能还会发生其他变动，可参考https://medium.com/the-node-js-collection/the-node-js-project-introduces-latest-release-line-node-js-10-x-bf07abfa9076 相关链接 Node.js 10文档 Node.js API 中文文档","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"node","slug":"node","permalink":"http://jiaxf.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://jiaxf.github.io/tags/npm/"}]},{"title":"PWA简介","slug":"PWA简介","date":"2018-04-25T01:06:57.000Z","updated":"2018-04-25T03:33:07.000Z","comments":true,"path":"2018/04/25/PWA简介/","link":"","permalink":"http://jiaxf.github.io/2018/04/25/PWA简介/","excerpt":"","text":"PWA简介Progressive Web Apps，简称PWA.渐进式提升Web App原生体验的技术方案，能给用户原生应用的体验。 PWA能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA本质上是WebApp，借助一些新技术也具备NativeApp的一些特性，兼具WebApp和NativeApp的优点。 PWA具有的一些特点及特性PWA特点： 可靠 即使在不稳定的网络环境下，也能瞬间加载并展现 体验 快速响应，并且有平滑的动画响应用户的操作 粘性 像设备上的原生应用，具有沉浸式饿得用户体验，用户可以添加到桌面 PWA具有特性 渐进式 - Progressive 适用于所有浏览器，因为它以渐进式增强作为宗旨开发 连接无关性 - 能够借助Service Worker在离线或这网络较差情况下正常访问 类似应用 - 由于在App Shell模型基础上开发，因为应具有NativeApp的交互和导航，给用户NativeApp的体验 持续更新 - 始终是最新的，无版本和更新问题 安全 - 通过HTTPS协议提供服务，防止窥探和确保内容不被篡改 可索引 - 应用清单文件和ServiceWorker可以让搜索引擎引到，从而将其识别为应用 粘性 - 通过推送离线通知等，可以让用户回流 免安装 - 用户可以添加常用的webapp到桌面，免去应用商店下载的麻烦 可链接 - 通过链接即可分享内容，无需下载安装 Web App Manifest(主屏图标) ServiceWorker(离线可用) Notification API &amp; Push API(离线通知) App Shell &amp; App Skeleton设计模型 PRPL Pattern(Push, Render, Pre-cache, Lazy-load) 安全HTTPS 交互 &amp; 动画 PWA通常是SPA 通常采用AppShell设计模型 ServiceWorker什么是Service WorkerW3C 组织早在 2014 年 5 月就提出过 Service Worker 这样的一个 HTML5 API ，主要用来做持久的离线缓存。浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。 W3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫 Web Worker 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 postMessage 方法告诉主线程，而主线程通过 onMessage 方法得到 Web Worker 的结果反馈。 Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。Service Worker 有以下功能和特性： 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。 一旦被 install，就永远存在，除非被 uninstall 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑） 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态） 离线内容开发者可控 能向客户端推送消息 不能直接操作 DOM 出于安全的考虑，必须在 HTTPS 环境下才能工作 异步实现，内部大都是通过 Promise 实现 Service Worker生命周期MDN 给出了详细的 Service Worker 生命周期图： 生命周期状态： 安装( installing )：这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。 install 事件回调中有两个方法： event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。 self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。 安装后( installed )：Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。 激活( activating )：在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。activate 回调中有两个方法： event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。 self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。 激活后( activated )：在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。 废弃状态 ( redundant )：这个状态表示一个 Service Worker 的生命周期结束。 进入废弃 (redundant) 状态的原因可能为这几种： 安装 (install) 失败 激活 (activating) 失败 新版本的 Service Worker 替换了它并成为激活状态 Service Worker支持的事件MDN 也列出了 Service Worker 所有支持的事件： 怎么使用Service worker 注册 安装serviceWoker ,通常需要在js主线程（常规页面的js）注册SeriveWorker来启动安装，这个过程将会通知浏览器我们的Service Worker线程的javascript文件在什么地方呆着。 1234567891011121314if('serviceWorker' in navigator) &#123; window.addEventListener('load', function () &#123; navigator.serviceWorker.register('/sw.js', &#123;scope: '/'&#125;) .then(function (registration) &#123; // 注册成功 console.log('ServiceWoker registration successful with scope:', registration.scope); &#125;) .catch(function (err) &#123; // 注册失败 console.log('ServiceWoker registration failed:', err); &#125;); &#125;);&#125; 注：查看是否注册成功，可以用chrome浏览器，输入 chrome://inspect/#service-workers 安装 1234567891011121314151617// 监听 service worker的install事件this.addEventListener('install', function(event)&#123; // 如果监听到了service worker 已经安装成功，就会调用event.waitUntil回调函数 event.waitUntil( // 安装成功后操作 CacheStorage缓存，使用之前需要先通过caches.open()打开对应缓存空间 cache.open('my-test-cache-v1').then(function(cache) &#123; // 通过cache缓存对象的addAll方法添加precache缓存 return cache.addAll([ '/', '/index.html', '/main.css', '/main.js', '/image.jpg' ]) &#125;); );&#125;); 自定义请求响应 任何被Service Worker控制的资源被请求时，都会触发fetch事件，这些资源包括了指定的scope内的html文档，和这些html文档内引用的其他任何资源。实现思路: Serivice Worker代理服务，给Service Woker添加一个fetch的事件监听器，接着调用event上的respondWith()方法来劫持HTTP响应，然后来更新他们。 1234567891011121314151617181920212223242526272829303132this.addEventListener('fetch', function(event) &#123; event.respondWith( caches.match(event.request).then(function(response) &#123; // 来来来，代理可以搞一些代理的事情 // 如果Service Worker有自己的返回，就直接返回，减少一次http请求 if(response)&#123; return response; &#125; // 如果service worker没有返回，那就得直接请求真实远程服务 var request = event.request.clone(); //把原始请求拷过来 return fetch(request).then(function(httpRes) &#123; // http请求的返回已被抓到，可以处置 // 请求失败了，直接返回失败的结果就好 if(!httpRes || httpRes.status !== 200)&#123; return httpRes; &#125; // 请求成功的话，将请求缓存起来 var responseClone = httpRes.clone(); cache.open('my-test-cache-v1').then(function (cache)&#123; cache.put(event.request, responseClone); &#125;); return httpRes; &#125;); &#125;) );&#125;); Service Worker版本更新 自动更新所有页面 12345678910111213141516171819202122232425// 安装阶段跳过等待，直接进入activeself.addEventListener('install', function(event) &#123; event.waitUntil(self.skipWaiting());&#125;);self.addEventListener('activate', function(event) &#123; event.waitUntil( Promise.all([ // 更新客户端 self.clients.claim(), // 清理旧版本 caches.keys().then(function(cacheList) &#123; return Promise.all( cacheList.map(function(cacheName) &#123; if(cacheName ！== 'my-test-cache-v1')&#123; return caches.delete(cacheName)； &#125; &#125;) ); &#125;) ]) );&#125;); 手动更新Service Worker 在页面中可以手动借助Registration.update()更新。 12345678var version = '1.0.1';navigator.serviceWorker.register('/sw.js').then(function(reg) &#123; if(localStorage.getItem('sw_version') !== version)&#123; reg.update().then(function() &#123; localStorage.setItem('sw_version', version) &#125;); &#125;&#125;); debug时更新 Service Worker被载入后立即激活可以保证每次/sw.js为最新。 123self.addEventListener('install', function()&#123; self.skipWaiting();&#125;); 意外惊喜 Service Worker的特殊之处除了由浏览器触发更新之外，还应用了特殊的缓存策略：如果该文件已24小时没有更新，当update触发时会强制更新。意外着最坏情况下Service Worker会每天更新一次。 ServiceWorker如何更新？ 浏览器每天至少更新一次ServiceWorker 注册新的Service Worker,带上版本号，如: /sw.js?t=201709091920 手动更新resistration.update() 逐字节对比新的sw文件和旧的sw，有区别才更新 123456789101112131415// index.htmlnavigator.serviceWoker.addEventListener('message', function(e)&#123; if(e.data === 'sw.update')&#123; //提醒用户刷新 &#125; &#125;);// sw.jsself.clients.matchAll().then(function(clients)&#123; if(clients &amp;&amp; clients.length)&#123; clients.forEach(function(client)&#123; client.postMessage('sw.update'); &#125;) &#125; &#125;) PWA SEO可以服务器端渲染Server Side Rendering(SSR).SSR中如何正确使用Service Worker 参考 LAVAS百度 个人分享PWA简介 QCon2018-《Lavas：PWA的探索与最佳实践》-彭星","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"}]},{"title":"区块链的几个基本概念","slug":"区块链的几个基本概念","date":"2018-04-20T06:36:45.000Z","updated":"2018-04-25T03:33:07.000Z","comments":true,"path":"2018/04/20/区块链的几个基本概念/","link":"","permalink":"http://jiaxf.github.io/2018/04/20/区块链的几个基本概念/","excerpt":"","text":"区块链的几个基本概念区块链（blockchain）本质上是一种特殊的分布式数据库。 首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。 其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。 区块链是去中心化的，没有管理员，是彻底无中心的。 区块区块链是由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。 每个区块包含两个部分 区块头(Head): 记录当前区块的特征值（当前时间、上一个区块的Hash、区块体的Hash） 区块体（body): 实际数据 两个重要推论： 推论1: 每个区块的哈希都是不一样的，可以通过哈希标识区块。 推论2：如果区块的内容变了，它的哈希一定会改变。 采矿添加新区块需要一定的计算，只有通过极其大量的计算，才能得到当前区块的有效哈希，从而把新区块添加到区块链。这个过程就叫做采矿（mining),因为计算有效哈希的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算哈希的机器就叫做矿机，操作矿机的人就叫做矿工。 难度系数区块头包含一个难度（difficulty),这个值决定了计算哈希的难度。区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。难度系数越大，目标值就越小。 区块链的适用场景 不存在所有成员都信任的管理当局 希尔的数据不要求实时使用 挖矿的收益能弥补本身成本 非对称加密加密和解密需要两把钥匙：一把公钥和一把私钥。公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息是你发的，且未被篡改，这就叫数字签名。 比特币特点 不会轻易被偷走 无法伪造 无法大批生成 区块链的作用区块链就是一个数据库，记载了所有的交易，用作中央记账系统，分布在无数个节点之上。 数字货币的本质就是一条可信的数据库记录。 比特币协议规定，分支点之后最先达到6个区块的那个分支被认定为正式的区块链，其他分支都被放弃。由于区块的生成速度由计算能力决定，所以到底哪一笔交易最后会被写入区块链，完全由它所在的分支能吸引多少计算能力决定。隐藏的逻辑是，如果大多数人（计算能力）选择相信某一笔交易，那么它就应该是真的。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"区块链","slug":"区块链","permalink":"http://jiaxf.github.io/tags/区块链/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2018-04-19T06:19:50.000Z","updated":"2018-04-19T06:44:50.000Z","comments":true,"path":"2018/04/19/函数式编程/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/函数式编程/","excerpt":"","text":"函数式编程Javascript的箭头函数ECMAScript2015引入箭头表达式。箭头函数其实是匿名函数，基本语法如下： (param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression // 等于 : =&gt; { return expression; } // 只有一个参数时,括号才可以不加: (singleParam) =&gt; { statements } singleParam =&gt; { statements } //如果没有参数,就一定要加括号: () =&gt; { statements } 示例： 12345678910var simple = a =&gt; a &gt; 15 ? 15 : a;simple(16); // 15simple(10); // 10let max = (a, b) =&gt; a &gt; b ? a : b;var arr = [5, 6, 13, 0, 1, 18, 23];var sum = arr.reduce((a, b) =&gt; a + b); //66var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18]var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 36, 46] 有些时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。 1234567891011function MakePowerFn(power) &#123; return function PowerFn(base) &#123; return Math.pow(base, power); &#125;&#125;power3 = MakePowerFn(3); // 制造一个X的3次方的函数power2 = MakePowerFn(2); // 制造一个X的2次方的函数console.log(power3(10)); // 10的3次方 1000console.log(power2(10)); // 10的2次方 100 用箭头函数 12345678910111213MakePowerFn = power =&gt; &#123; return base =&gt; &#123; return Math.pow(base, power); &#125;&#125;// 简化MakePowerFn = power =&gt; base =&gt; Math.pow(base, power)// 加上括号MakePowerFn = (power) =&gt; ( (base) =&gt; (Math.pow(base, power)) ) 匿名函数的递归函数式编程立志于用函数表达式来消除有状态的函数，以及for/while循环，所以在函数式编程里不应该用for/while循环，而要改用递归(递归的性能很差，所以，一般用尾递归来做优化，也就是把函数的计算状态当参数一层一层往下传递，这样语言的编译器后解释器就需要用函数栈来帮你保存函数的内部变量的状态了)。 递归的代码就是函数自己调用自己，比如求阶乘 123function fact(n)&#123; return n == 0 ? 1 : n * fact(n-1);&#125; 对于匿名函数，可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了。 123456function combinator(func) &#123; func(func);&#125;// 箭头函数式的匿名函数（func） =&gt; (func(func)) 阶乘代码重构12345678910111213funtion fact(func, n)&#123; return n == 0 ? 1: n * func(func, n-1);&#125;// 匿名函数版var fact = (func, n) =&gt; (n == 0 ? 1 : func(func, n-1));fact(fact, 5)// 函数体声明时调用自己（func, x) =&gt; func(func, x)( (func, n) =&gt; ( n ==0 ? 1 : n * func(func, n-1)), // 第一个调用参数 5 // 第二个调用参数); 动态高级函数的递归递归版高阶函数 1234567891011121314151617181920212223242526272829HighOrderFact = function(func)&#123; return function(n)&#123; return n == 0 ? 1 : func(func)(n-1); &#125;;&#125;// 需要一个函数做参数，然后返回这个函数的递归版本fact = HighOrderFact(HighOrderFact);fact(5);HighOrderFact(HighOrderFact)(5);fact = function(hifunc) &#123; return hifunc(hifunc);&#125;( // 调用参数是一个函数 function(func)&#123; return function(n)&#123; return n == 0 ? 1 : n * func(func)(n-1); &#125;; &#125;);// 调用fact(5);// 箭头函数重构fact = (highfunc =&gt; highfunc(highfunc)) ( func =&gt; n =&gt; n == 0 ? 1 : n * func(func)(n-1)); 重构之前的程序123456789101112131415161718192021222324252627282930313233 // 查找数组正常版本 function find(x, y) &#123; for(let i = 0; i&lt; x.length; i++)&#123; if(x[i] == y) return i; &#125; return null; &#125; // 干掉for，搞成递归版本 funcion find(x, y, i=0)&#123; if( i &gt;= x.length) return null; if( x[i] == y) return i; return find(x, y, i+1); &#125; // 继续重构 带实参的匿名函数版本((func, x, y, i) =&gt; func(func, x,y i)) ( // 函数体 (func, x, y, i=0) =&gt; ( i&gt;= x.length ? null : x[i] == y ? i : func(func, x, y, i+1) ), // 第一个调用参数 arr, // 第二个调用参数 2 // 第三个调用参数 ) // 引入高级函数，去除实参const find = （highfunc =&gt; highfunc(highfunc))( func =&gt; (x, y, i =0 ) =&gt; ( i &gt;= x.length ? null : x[i] == y ? i : func(func)(x, y, i+1) )) ; 可以参考以下两篇文章 《The Y Combinator (Slight Return)》 《Wikipedia: Fixed-point combinator》","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"Thinking in Ramda 4","slug":"4-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/4-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/4-Thinking in Ramda/","excerpt":"Thinking in Ramda: Declarative ProgrammingAs we start writing small functional building blocks and combining them, we find that we have to write a lot of functions that wrap JavaScript’s operators such as arithmetic, comparison, logic, and control flow. This can feel tedious, but Ramda has our back. There are many different ways to divide up the programming language/style landscape. There’s static typing vs dynamic typing, interpreted languages vs compiled languages, low-level vs high-level, etc. Another such division is imperative programming vs declarative programming.","text":"Thinking in Ramda: Declarative ProgrammingAs we start writing small functional building blocks and combining them, we find that we have to write a lot of functions that wrap JavaScript’s operators such as arithmetic, comparison, logic, and control flow. This can feel tedious, but Ramda has our back. There are many different ways to divide up the programming language/style landscape. There’s static typing vs dynamic typing, interpreted languages vs compiled languages, low-level vs high-level, etc. Another such division is imperative programming vs declarative programming.Functional programming is considered a subset of declarative programming. In a functional program, we define functions and then tell the computer what to do by combining these functions. Even in declarative programs, it is necessary to do similar tasks to those we do in imperative programs. Control flow, arithmetic, comparison, and logic are still the basic building blocks we have to work with. But we need to find a way to express these constructs in a declarative way. Declarative ReplacementsSince we’re programming in JavaScript, an imperative language, it’s fine to use the standard imperative constructs when writing “normal” JavaScript code. But when we’re writing functional transformations using pipelines and similar constructs, the imperative constructs don’t play well. Ramda provides add, subtract, multiply, and divide functions to use in place of the standard arithmetic operators. ComparisonNotice that some of our functions are using standard comparison operators (=== and `&gt;= in this case). As you might suspect by now, Ramda also provides replacements for these. Let’s modify our code to use equals in place of === and gte in place of &gt;=. Ramda also provides gt for &gt;, lt for &lt;, and lte for &lt;=. In addition to equals, there is identical for determining if two values reference the same memory. There are a couple of common uses of ===: checking if a string or array is empty (str === &#39;&#39; or arr.length === 0), and checking if a variable is null or undefined. Ramda provides handy functions for both cases: isEmpty and isNil. Logicwe used the both and either functions in place of &amp;&amp; and || operations. We also talked about complement in place of !. But sometimes we need to apply &amp;&amp;, ||, and ! to disparate values. For those cases, Ramda gives us and, or, and not functions. I think of it this way: and, or, and not work with values, while both, either, and complement work with functions. defaultTo checks if the second argument isNil. If it isn’t, it returns that as the value, otherwise it returns the first value. Conditionals IfElse ConstantsConstant functions are quite useful in situations like this. As you might imagine, Ramda provides us a shortcut. In this case, the shortcut is named always. Ramda also provides T and F as further shortcuts for always(true) and always(false). Identityidentity can take more than one argument, but it always returns its first argument. If we want to return something other than the first argument, there’s the more general nthArg function. It’s much less common than identity. When And UnlessCond Cite From « Thinking in Ramda: Declarative Programming »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Thinking in Ramda 5","slug":"5-Thinking in Radam","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/5-Thinking in Radam/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/5-Thinking in Radam/","excerpt":"Thinking in Ramda: Pointfree StylePointfree Style Put the data last Curry all the things 12345const water = cond([ [equals(0), always('water freezes at 0°C')], [equals(100), alwyas('water boils at 100°C')], [T, temp =&gt; `nothing sepcial happends at $&#123;temp&#125;°C`]]) Multi-argument Functions123456const titlesForYear = curry((year, books) =&gt; pipe( filter(publishedInYear(year)), map(book =&gt; book.title) )(books)) 12345const titlesForYear = year =&gt; pipe( filter(publishedInYear(year)), map(book =&gt; book.title) )","text":"Thinking in Ramda: Pointfree StylePointfree Style Put the data last Curry all the things 12345const water = cond([ [equals(0), always('water freezes at 0°C')], [equals(100), alwyas('water boils at 100°C')], [T, temp =&gt; `nothing sepcial happends at $&#123;temp&#125;°C`]]) Multi-argument Functions123456const titlesForYear = curry((year, books) =&gt; pipe( filter(publishedInYear(year)), map(book =&gt; book.title) )(books)) 12345const titlesForYear = year =&gt; pipe( filter(publishedInYear(year)), map(book =&gt; book.title) ) Refactoring To Pointfree12345678910const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)// 改写const isCitizen = person =&gt; either(wasBornInCountry, wasNaturalized)(person)const isEligibleToVote = pserson =&gt; both(isOver18, isCitizen)(person)// with pointfree styleconst isCitizen= either（wasBornInCountry, wasNaturalized)const isEligibleToVote= both(isOver18, isCitizen) ## Conclusion Pointfree style, also known as tacit programming, can make our code clearer and easier to reason about. By refactoring our code to combine all of our transformations into a single function, we end up with smaller building blocks that can be used in more places. Cite from « Thinking in Ramda: Pointfree Style »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Thinking in Ramda 7","slug":"7-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/7-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/7-Thinking in Ramda/","excerpt":"Thinking in Ramda: Immutability and ArraysReading Array ElementsRamda functions for reading array elements nth and slice and contains 12345const numbers = [10,20,30,40,50,60]nth(3, numbers) // =&gt; 40 (0-based indexing)nth(-2, numbers) // =&gt;50 (negative numbers start from the right)slice(2, 5, numbers) // =&gt; [30,40, 50] (see below)contains(20, numbers) // =&gt; true nth(0) equals head, nth(-1) equals last. It also provides functions for accesing all-but-the-first element tail,all-but-the-last element init,the first N elements take(N), and the last N elments takeLast(N).","text":"Thinking in Ramda: Immutability and ArraysReading Array ElementsRamda functions for reading array elements nth and slice and contains 12345const numbers = [10,20,30,40,50,60]nth(3, numbers) // =&gt; 40 (0-based indexing)nth(-2, numbers) // =&gt;50 (negative numbers start from the right)slice(2, 5, numbers) // =&gt; [30,40, 50] (see below)contains(20, numbers) // =&gt; true nth(0) equals head, nth(-1) equals last. It also provides functions for accesing all-but-the-first element tail,all-but-the-last element init,the first N elements take(N), and the last N elments takeLast(N). Adding, Updating, and Removing Array Elements insert update append prepend update concat concatAfter = flip(concat) Transforming Elements update adjust evolve Cite From « Thinking in Ramda: Immutability and Arrays »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"redis配置","slug":"redis配置","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/redis配置/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/redis配置/","excerpt":"redis 配置redis.conf 配置项说明如下： Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16","text":"redis 配置redis.conf 配置项说明如下： Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb 指定本地数据库存放目录dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof 当master服务设置了密码保护时，slav服务连接master的密码masterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区maxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法hash-max-zipmap-entries 64hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include /path/to/local.conf","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"}]},{"title":"Thinking in Ramda 9","slug":"9-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/9-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/9-Thinking in Ramda/","excerpt":"Thinking in Ramda: Wrap-UpRamda has some underlying principles that drive its API: Data last: Almost all of the functions take the data parameter as the last parameter. Currying: Almost every function in Ramda is “curried”. That is, you can call a function with only a subset of its required arguments, and it will return a new function that takes the remaining arguments. Once all of the arguments are provided, the original function is invoked.","text":"Thinking in Ramda: Wrap-UpRamda has some underlying principles that drive its API: Data last: Almost all of the functions take the data parameter as the last parameter. Currying: Almost every function in Ramda is “curried”. That is, you can call a function with only a subset of its required arguments, and it will return a new function that takes the remaining arguments. Once all of the arguments are provided, the original function is invoked. Summary Getting started introduces us to the idea of functions, pure functions, and immutablilty. If the gets us started by looking at the collection iteration functions like map, filter, and reduce. Combinging Functions shows us that we can combine functions in various ways using tools such as both, either, pipe and compose. Partial Application help us that it can be useful to only supply some of the arguments to a function, allowing a later function to supply the rest.We use partial and curry to help us with this and learn about flip and the placeholder(__). Declarative Programming teaches us about the difference between imperative and declarative programming.We learn how to use Ramda’s declarative replacements for arithmetic, comparisons,logic and conditionals. Pointfree Style introduces us the idea of pointfree style,also known as tacit programming.In pointfree style,we don’t actually see the data parameter that we’ar operating on;it’s implicit. Our programs are made up of small, simple building blocks that are combined together to do what we need. Only at the end do we apply out compound functions to the actual data. Immutability and Objects returns us to the idea of working declaratively, this time giving us the tools we need to read, update, delete, and transform properties of objects. Immutability and Arrays continues the theme and shows us how to do the same for arrays. Lenses concludes by introducing the concept of a lens, a construct that allows us to focus on a small part of a larger data structure. Using the view, set, and over functions, we can read, update, and transform the focused value in the context of its larger data structure. Cite from « Thinking in Ramda: Wrap-Up »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Thinking in Ramda 6","slug":"6-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/6-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/6-Thinking in Ramda/","excerpt":"Thinking in Ramda: Immutability and ObjectsReading Object PropertiesWe can make the functions more declarative using equals and gte. PropFortunately, Ramda can help us out.It provides the prop function for accesing properties of an object. PickWhere prop reads a single property from an object and returns the value, p ick reads multiple properties from an object and returns a new object with just those properties.","text":"Thinking in Ramda: Immutability and ObjectsReading Object PropertiesWe can make the functions more declarative using equals and gte. PropFortunately, Ramda can help us out.It provides the prop function for accesing properties of an object. PickWhere prop reads a single property from an object and returns the value, p ick reads multiple properties from an object and returns a new object with just those properties. HASIf we just want to know if an object has a property without reading the value,we can use has for checking own properties,and hasIn for checking up the prototype chain: has(&#39;name&#39;, person). PATHWhere prop reads a property from an object, path dives into nested objects. For example, we could access the zip code from a deeper structure as path([‘address’, ‘zipCode’], person). Note that path is more forgiving than prop. path will return undefined if anything along the path (including the original argument) is null or undefined whereas prop will raise an error. propOr / pathOrpropOr and pathOr are similar to prop and path combined with defaultTo. They let you provide a default value to use if the property or path cannot be found in the target object. For example, we can provide a placeholder when we don’t know a person’s name: propOr(&#39;&lt;Unnamed&gt;&#39;, &#39;name&#39;, person). Note that unlike prop, propOr will not raise an error if person is null or undefined; it will instead return the default value. keys / valueskeys returns an array containing the names of all of the own properties in an object. values returns the values of those properties. These functions can be useful when combined with the collection iteration functions we learned about in Part 1. merging ObjectSometimes, you’ll want to merge two objects together. A common case is when you have a function that takes named options and you want to combine those options with a set of default options. Ramda provides merge for this purpose. 1234function f(a,b,options = &#123;&#125;) &#123; const defaultOptions = &#123;value:42, local:true&#125; const finalOptions = merge(defaultOptions, options)&#125; merge returns a new object containing all of the properties and values from both objects. If both objects have the same property, the value from the second argument is used. ConclusionThis has given us a nice set of tools for working with objects in a declarative and immutable way.We can now read, add, update, delete, and transform properties in objects without changing the original objects. And we can do these things in a way that works when combining functions. Cite From « Thinking in Ramda: Immutability and Objects »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"前端自适应css3相对单位rem","slug":"前端自适应CSS3相对单位rem","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/前端自适应CSS3相对单位rem/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/前端自适应CSS3相对单位rem/","excerpt":"相对单位remrem(font size of the root element)是指相对于根元素的字体大小的单位。 rem是相对长度单位，相对于根元素（即html元素） font-size计算值的倍数。使用： 根据根标签html设置文字大小后（大部分浏览器默认为16px），其他标签设置rem都是html大小的倍数。 移动端开发使用em作为单位 1234567891011html&#123; font-size: 16px;&#125;body&#123; font-size: 1rem; // 16px&#125;h1&#123; font-size: 0.625rem // 10px&#125; web app的几种屏幕适配：1. 固定高度（流式布局）流式布局通过百分比来定义宽度，但是高度大都是用px固定住。 高度不变，宽度拉伸。 2. 固定宽度固定宽度，超出部分留白。","text":"相对单位remrem(font size of the root element)是指相对于根元素的字体大小的单位。 rem是相对长度单位，相对于根元素（即html元素） font-size计算值的倍数。使用： 根据根标签html设置文字大小后（大部分浏览器默认为16px），其他标签设置rem都是html大小的倍数。 移动端开发使用em作为单位 1234567891011html&#123; font-size: 16px;&#125;body&#123; font-size: 1rem; // 16px&#125;h1&#123; font-size: 0.625rem // 10px&#125; web app的几种屏幕适配：1. 固定高度（流式布局）流式布局通过百分比来定义宽度，但是高度大都是用px固定住。 高度不变，宽度拉伸。 2. 固定宽度固定宽度，超出部分留白。 3. 响应式4. 设置viewport进行缩放1&lt;meta name=\"viewprt\" content=\"width=320,maximun-scale=1.3,user-scalable=no\"&gt; 例如：可以以320宽度为基准，进行缩放 5. rem能等比例适配所有屏幕通过设置html的字体大小可以控制rem的大小，改变html的font-size可以等比改变所有用了rem单位的元素，任何分辨率下，页面的排版都是按照等比例进行切换。可以通过js根据浏览器当前的分辨率改变font-size的值来实现缩放。 12345678910111213(function(doc, win)&#123; var docEle = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange': 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth; if(!clientWidth) return;; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if(!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(doucment, window); rem使用的浏览器兼容性 常用的rem 单位换算","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://jiaxf.github.io/tags/web/"},{"name":"前端","slug":"前端","permalink":"http://jiaxf.github.io/tags/前端/"},{"name":"css3","slug":"css3","permalink":"http://jiaxf.github.io/tags/css3/"}]},{"title":"Web Worker study","slug":"webWorkers","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/webWorkers/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/webWorkers/","excerpt":"Web WorkersjavaScript属于单线程环境，无法同时运行多个脚本。HTML5提供了WebWorker，为JavaScript引入线程技术。 Web Worker简介WebWorker规范定义了在网络应用中生成背景脚本的API。可以通过Web Worker执行线程。例如触发长时间运行的脚本以处理计算密集型任务，同时却不会阻碍UI或其他脚本处理用户互动。 Woker利用类似线程的消息传递实现并行。 Web Worker的类型 专用Woker 共有Woker 使用入门Web Worker在独立线程中运行，因此，它们执行的代码需要保存在一个单独的文件中。 创建新的Worker对象 1var worker = new Woker('task.js'); 创建Worker后通过调用postMessage() 方法启动 1worker.postMessage(); // start the worker","text":"Web WorkersjavaScript属于单线程环境，无法同时运行多个脚本。HTML5提供了WebWorker，为JavaScript引入线程技术。 Web Worker简介WebWorker规范定义了在网络应用中生成背景脚本的API。可以通过Web Worker执行线程。例如触发长时间运行的脚本以处理计算密集型任务，同时却不会阻碍UI或其他脚本处理用户互动。 Woker利用类似线程的消息传递实现并行。 Web Worker的类型 专用Woker 共有Woker 使用入门Web Worker在独立线程中运行，因此，它们执行的代码需要保存在一个单独的文件中。 创建新的Worker对象 1var worker = new Woker('task.js'); 创建Worker后通过调用postMessage() 方法启动 1worker.postMessage(); // start the worker 通过消息传递与Worker通信Worker与其父网页之间的通信是通过事件模型和postMessage()方法实现。 postMessage()可以接受字符串或JSON对象作为单个参数，新式浏览器的最新版支持传递JSON对象。 123456var worker = new Worker('doWork.js');worker.addEventListener('message', function(e)&#123; console.log('Worker said: ', e.data);&#125;, false);worker.postMessage('Hello World'); // send data to our worker doWork.js(Worker): 123self.addEventListener('message', function(e)&#123; self.postMessage(e.data);&#125;, false); 在主网页中调用postMessage()时，Worker通过定义message事件的onmessage处理程序来实现处理消息。可以在Event.data中访问消息（“Hello World”），postMessage()也是将数据传回主线程的一种方法。 在主网页和Worker之间传递的消息是复制而不是共享的。系统将对象传递给worker后，会将其序列化，随后在另一端取消序列化。由于网页和Worker并不共享同一实例，因此每次传递时都要进行复制。大部分浏览器通过在任一端上对值进行自动JSON编码/解码来实施此功能。 一个使用JSON对象传递消息的更复杂的示例。 主脚本：12345678910111213141516171819202122232425&lt;button onclick=\"sayHI()\"&gt;Say HI&lt;/button&gt;&lt;button onclick=\"unknownCmd()\"&gt;Send unknown command&lt;/button&gt;&lt;button onclick=\"stop()\"&gt;Stop worker&lt;/button&gt;&lt;output id=\"result\"&gt;&lt;/output&gt;&lt;script&gt; function sayHI() &#123; worker.postMessage(&#123;'cmd': 'start', 'msg': 'Hi'&#125;); &#125; function stop() &#123; // Calling worker.terminate() from this script would also stop the worker. worker.postMessage(&#123;'cmd': 'stop', 'msg': 'Bye'&#125;); &#125; function unknownCmd() &#123; worker.postMessage(&#123;'cmd': 'foobard', 'msg': '???'&#125;); &#125; var worker = new Worker('doWork2.js'); worker.addEventListener('message', function(e) &#123; document.getElementById('result').textContent = e.data; &#125;, false);&lt;/script&gt; doWork2.js： 1234567891011121314self.addEventListener('message', function(e) &#123; var data = e.data; switch(data.cmd)&#123; case 'start': self.postMessage('Worker started: ' + data.msg); break; case 'stop': self.postMessage('Worker stopped: ' + data.msg + ' .(buttons will no longer work)'); self.close(); // Terminates the worker. break; default: self.postMessage('Unknown command: ' + data.msg); &#125;;&#125;, false); 停止Worker的方法有两种：在主网页中调用worker terminate()或在Worker本身内部调用self.close(). Worker环境Worker作用域就Worker来说，self和this指的都是Worker的全局作用域。 12345678addEventListener('message', function(e)&#123; var data = e.data; switch(data.cmd) &#123; case 'start': postMessage('Worker started:' + data.msg); // 直接方法 break; &#125;&#125;, false); 适用于Worker的功能由于Web Worker的多线程行为，所以它们只能使用JavaScript功能的子集： navigator对象 location对象（只读） XMLHttpRequest setTimeout()/clearTimeout()和setInterval()/clearInterval() 应用缓存 使用importScript()方法导入外部脚本 生成其他Web Worker Worker无法使用： DOM(非线程安全) window对象 document对象 parent对象 加载外部脚本可以通过importScripts()函数将外部脚本文件或库加载到worker中。 12importScripts('script1.js');importScripts('script2.js'); 也可以写成单个导入语句：1importScripts('script1.js', 'script2.js'); 子WorkerWorker可以生成子Worker。子Worker注意事项： 子Worker必须托管在与父网页相同的来源中 子Woker中的URI应相对于父Worker的位置进行解析。 主网页和Worker之间传递的消息是复制而不是共享。 内嵌Worker12345678910111213// Prefixed in Webkit， chrome12，and FF6： window.WebKitBlobBuilder, window.MozBlobBuildervar bb = new BlobBuilder();bb.append(\"onmessage = function(e) &#123; postMessage('msg from worker')&#125;\");// Obtain a blob URL reference to our worker 'file'.// Note: window.webkitURL.createObjectURL() in Chrome 10 +.var blobURL = window.URL.createObjectURL(bb.getBlob());var worker = new Worker(blobURL);worker.onmessage = function(e) &#123; // e.data == 'msg from worker'&#125;;worker.postMessage(); // start the worker. Blob网址对window.URL.createObjectURL()的调用十分奇妙，此方法创建一个简单的网址字符串，该字符串可用于DOM File 或 Blob对象中存储的参考数据。例如：1blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1 Blob网址是唯一的，且只要应用存在，该网址就会一直有效。可以通过将Blob网址传递给window.URL.revokeObjectURL()来明确发布该网址： 1window.URL.revokeObjectURL(blobURL); // window.webkitURL.createObjectURL() in Chrome 10+. 在Chrome浏览器中，用chrome://blob-internals/可以查看创建的所有Blob网址。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYEP html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"log\"&gt;&lt;/div&gt; &lt;script id=\"worker1\" type=\"javascript/worker\"&gt; // This script won't be parsed by JS engines because its type is javascript/worker. self.onmessage = function(e) &#123; self.postMessage('msg from worker'); &#125;; // Rest of your worker code goes here. &lt;/script&gt; &lt;script&gt; function log(msg) &#123; var fragment = document.createDocumentFragment(); fragment.appendChild(document.createTextNode(msg)); fragment.appendChild(document.createElement('br')); document.querySelector('#log').appendChild(fragment); &#125; var bb = new BlobBuilder(); bb.append(document.querySelector('#worker1').textContent); var worker = new Worker(window.URL.createObjectURL(bb.getBlob())); worker.onmessage = function(e) &#123; log(\"Received:\" + e.data); &#125; worker.postMessage(); // Start the worker &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 加载外部脚本在内嵌Worker中利用importScripts()的一种方法是通过将相关网址传递给内嵌Worker并手动构建绝对网址来”导入”运行您主脚本的当前网址。这可以确保外部脚本是从同一来源导入的。 123456789101112131415161718&lt;script id=\"worker2\" type=\"javascript/worker\"&gt;self.onmessage = function(e)&#123; var data = e.data; if(data.url)&#123; var url = data.url.href; var index = url.indexOf('index.html'); if(index != -1)&#123; url = url.substring(0, index); &#125; importScipts(url + 'engine.js'); &#125;&#125;&lt;/script&gt;&lt;script&gt; var worker = new Worker(window.URL.createObjectURL(bb.getBlob())); worker.postMessage(&#123;url: document.loacation&#125;);&lt;/script&gt; 处理错误处理Web Worker中出现的错误，如果在执行Worker时出现错误，就会触发ErrorEvent. filename 导致错误的Worker脚本的名称 lineno 出现错误的行号 message 有关错误的实用说明 123456789101112131415161718&lt;output id=\"error\" style=\"color: red;\"&gt;&lt;/output&gt;&lt;output id=\"result\"&gt;&lt;/output&gt;&lt;script&gt; function onError(e) &#123; document.getElementById('error').textContent = [ 'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message].join(''); &#125; function onMsg(e) &#123; document.getElementById('result').textContent = e.data; &#125; var worker = new Worker('workerWithError.js'); worker.addEventListener('message', onMsg, false); worker.addEventListener('error', onError, false); worker.postMessage(); // Start worker without a message.&lt;/script&gt; 安全说明本地访问限制由于google Chrome浏览器的安全限制，Worker无法在本地运行（如通过file://),且会在不显示任何提示的情况下失败。要通过file:// 方案运行，需使用–allow-file-access-files标记设置来运行Chrome浏览器。 同源注意事项Worker 脚本必须是将相同方案作为调用网页的外部文件。因此，您无法通过 data: 网址或 javascript: 网址加载脚本，且 https: 网页无法启动以 http: 网址开头的 Worker 脚本。 用例 预先抓取和/或缓存数据以便稍后使用 突出显示代码语法或其他实时文本格式 拼写检查程序 分析视频或音频数据 背景 I/O 或网络服务轮询 处理较大数组或超大 JSON 响应 &lt;canvas &gt;中的图片过滤 更新本地网络数据库中的多行内容","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"web","slug":"web","permalink":"http://jiaxf.github.io/tags/web/"}]},{"title":"函数式编程入门（2）","slug":"applicativeFunctor","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/applicativeFunctor/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/applicativeFunctor/","excerpt":"","text":"Applicative functor应用applicative functor作为一个接口可以让不通funcotr可以相互应用（apply）的能力。 协调与激励1234567// Http.get :: String -&gt; Task Error HTMLvar renderPage = curry(function(destinations, event) &#123; /* render page */&#125;);Task.of(renderPage).ap(Http.get('/destinations')).ap(Http.get('/events'))// Task(\"&lt;div&gt;some page with dest and events&lt;/div&gt;\") 两个请求将会同时立即执行，当两者的响应都返回之后，renderPage 就会被调用。这与 monad 版本的那种必须等待前一个任务完成才能继续执行后面的操作完全不同。本来我们就无需根据目的地来获取事件，因此也就不需要依赖顺序执行。 再次强调，因为我们是使用局部调用的函数来达成上述结果的，所以必须要保证 renderpage 是 curry 函数，否则它就不会一直等到两个 Task 都完成。而且如果你碰巧自己做过类似的事，那你一定会感激 applicative functor 这个异常简洁的接口的。这就是那种能够让我们离“奇点”（singularity）更近一步的优美代码。 123456789101112131415161718// 帮助函数：// ===================// $ :: String -&gt; IO DOMvar $ = function(selector) &#123; return new IO(function() &#123; return document.querySelector(selector) &#125;);&#125;// getVal :: String -&gt; IO Stringvar getVal = compose(map(_.prop('value')), $);// Exapmle// ===================// signIn :: String -&gt; String -&gt; Bool -&gt; Uservar signIn = curry(function(username, password, remember_me)) &#123;/* singing in */&#125;IO.of(signIn).ap(getVal('#email')).ap(getVal('#password')).ap(IO.of(false)); signIn 是一个接收 3 个参数的 curry 函数，因此我们需要调用 ap 3 次。在每一次的 ap 调用中，signIn 就收到一个参数然后运行，直到所有的参数都传进来，它也就执行完毕了。我们可以继续扩展这种模式，处理任意多的参数。另外，左边两个参数在使用 getVal 调用后自然而然地成为了一个 IO，但是最右边的那个却需要手动 lift，然后变成一个 IO，这是因为 ap 需要调用者及其参数都属于同一类型。 lift我们来试试以一种 pointfree 的方式调用 applicative functor。因为 map 等价于 of/ap，那么我们就可以定义无数个能够 ap 通用函数。 12345678var liftA2 = curry(function(f, functor1, functor2) &#123; return functor1.map(f).ap(functor2);&#125;);var liftA3 = curry(function(f, functor1, functor2, functor3) &#123; return functor1.map(f).ap(functor2).ap(functor3);&#125;)// liftA4, etc 操作符在haskell、scala、PureScript以及swift等语言中，开发者可以创建自定义的中缀操作符(infix operators) 12-- haskelladd &lt;$&gt; Right 2 &lt;*&gt; Right 3 1map(add, Right(2)).ap(Right(3)) &lt;$&gt; 就是map（亦即fmap）， &lt;*&gt;就是ap。 衍生函数（derived function）of/ap 等价于map。 1234// 从of/ap衍生出的mapX.prototype.map = function(f) &#123; return this.constructor.of(f).ap(this);&#125; 如果已经有chain函数，可以免费得到functor 和 applicative： 1234567891011121314// 从chain 衍生出的mapX.prototype.map = function() &#123; var m = this; return m.chain(function(a) &#123; return m.constructor.of(f(a)); &#125;);&#125;// 从 chain/map 衍生出的apX.prototype.ap = function(other) &#123; return this.chain(function(f) &#123; return other.map(f); &#125;);&#125; 定律applicative functor 是“组合关闭”（closed under composition）的，意味着 ap 永远不会改变容器类型。 ### 同一律12// 同一律A.of(id).ap(v) == v 同态12//同态A.of(f).ap(A.of(x)) == A.of(f(x)) 同态就是一个能够保持接结构的映射（structure preserving map).实际上，funcotr就是一个再不通范畴间的同态，因为funcotr在经过映射之后保持了原始范畴的结构。 互换（interchange）互换（interchange）表明的是选择让函数再ap的左边还是右边发生lift是无关紧要的。 12// 互换v.ap(A.of(x)) == A.of(function(f) &#123; return f(x)&#125;).ap(v) 1234var v = Task.of(_.reverse);var x = 'Sparklehorse';v.ap(Task.of(x)) == Task.of(function(f) &#123; return f(x)&#125;).ap(v) 组合（composition)组合不过是在检查标准的函数组合是否适用于容器内部的函数调用。 12// 组合A.of(compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w)); 12345var u = IO.of(_.toUpper);var v = IO.of(_.concat(\"&amp; beyond\"));var w = IO.of(\"lood bath\");IO.of(_compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w)) 总结函数式嗯编程","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"范畴学基本知识","slug":"category theory","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/category theory/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/category theory/","excerpt":"范畴学基本知识范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（set theory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：","text":"范畴学基本知识范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（set theory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式： 在范畴学中，有一个概念叫做…范畴。有着以下这些组件（component）的搜集（collection）就构成了一个范畴： 对象的搜集 态射的搜集 态射的组合 identity 这个独特的态射 对象的搜集 对象就是数据类型，例如 String、Boolean、Number 和 Object 等等。通常我们把数据类型视作所有可能的值的一个集合（set）。像 Boolean 就可以看作是 [true, false] 的集合，Number 可以是所有实数的一个集合。把类型当作集合对待是有好处的，因为我们可以利用集合论（set theory）处理类型。 态射的搜集 态射是标准的、普通的纯函数。 态射的组合 compose 函数是符合结合律的，这并非巧合，结合律是在范畴学中对任何组合都适用的一个特性。 这张图展示了什么是组合： 123var g = function(x)&#123; return x.length; &#125;;var f = function(x)&#123; return x === 4; &#125;;var isFourLetterWord = compose(f, g); identity 这个独特的态射 让我们介绍一个名为 id 的实用函数。这个函数接受随便什么输入然后原封不动地返回它： 1var id = function(x)&#123; return x; &#125;; 除了类型和函数，还有什么范畴呢？还有很多，比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数对象，以 &gt;= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。 命令式编程 和 申明式编程 区别123456789// 命令式var makes = [];for (i = 0; i &lt; cars.length; i++) &#123; makes.push(cars[i].make);&#125;// 声明式var makes = cars.map(function(car)&#123; return car.make; &#125;); 12345678// 命令式var authenticate = function(form) &#123; var user = toUser(form); return logIn(user);&#125;;// 声明式var authenticate = compose(logIn, toUser); 声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"函数式编程入门","slug":"curry","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/curry/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/curry/","excerpt":"curringA curried function is one where multiple arguments are descirbed by a series of oneargument funtions.For example, curried addition would be : 记录传入的参数，在需要的时候求值。 1234var curry = require('curry')var add = curry(function(a, b)&#123; return a + b&#125;)var add100 = add(100)add100(1) // =101 Curry allows you can aslo call a function with multiple arguments at once: 1234var sum3 = curry(function(a, b, c) &#123; return a + b + c&#125;)sum3(1,2,3) // =6sum3(1)(2,3) // =6sum3(1,2)(3) // =6","text":"curringA curried function is one where multiple arguments are descirbed by a series of oneargument funtions.For example, curried addition would be : 记录传入的参数，在需要的时候求值。 1234var curry = require('curry')var add = curry(function(a, b)&#123; return a + b&#125;)var add100 = add(100)add100(1) // =101 Curry allows you can aslo call a function with multiple arguments at once: 1234var sum3 = curry(function(a, b, c) &#123; return a + b + c&#125;)sum3(1,2,3) // =6sum3(1)(2,3) // =6sum3(1,2)(3) // =6 what advantage to use curry?If you’re not used to languages in whice curried functions are part of daily life,it’s probably not obvious what advantage this gives us. To my mind,the two main onesare: Little pieces can be configured and reused with ease, without clutter; Functions are used throughout. The little piecesTake an obvious example;mapping over a collection to get the ids of its members: 12var objects = [&#123;id:1&#125;, &#123;id:2&#125;, &#123;id:3&#125;]objects.map(function(o)&#123; return o.id&#125;) MAP over OBJECTS to getIDS There’s a lot of implementation cruft in just that line;in the form of the functiondefinition.Let’s clean that up: 12var get = curry(function(property, object) &#123;return object[property]&#125;)objects.map(get('id')) // =[1,2,3] Now we’re talking in terms of the real logic of the operation - map over these objects,getting their ids.BAM. What we’v really created in the get function is a functionthat can be partially configured. What if we want to re-use the ‘get ids from a list of objects’ functionality, though?Let’s do it the naive way: 12345var getIDs = function(objects) &#123; return objects.map(get('id'))&#125;getIDs(objects) // =[1,2,3] 1234var map = curry(function(fn, value) &#123; return value.map(fn)&#125;)var getIDs = map(get('id'))getIDs(objects) // =[1,2,3] Functions through and throughoutAnother avantage of this approach is that it encourages the creation of functions;rather than of methods. While methods are beautiful things - allowing polymorphism,and very readable code - they aren’t always the tool for the job, such as in heavlilyasync code. Data1234567&#123; \"user\": \"hughfdjackson\", \"posts\": [ &#123; \"title\": \"why curry?\", \"contents\": \"...\" &#125;, &#123; \"title\": \"prototypes: the short(est possible) story\", \"contents\": \"...\" &#125; ]&#125; Your task is to get the titles for each of this users posts. 123456fetchFromServer() .then(JSON.parse) .then(function(data)&#123; return data.posts&#125;) .then(function(posts) &#123; return posts.map(function(post)&#123;return post.title&#125;) &#125;) Since chains of promises(or, if you prefer, callbacks) fundamentally work withfunctions,you can’t easilly just map over an value when one is available fromthe server without first wrapping it up in all that visual(and mental) clutter. Let’s go again, this time using the tools we’ve already defined: 1234fetchFromSever() .then(JSON.parse) .then(get('posts')) .then(map(get('title'))) This is lean logic, easily expressed; something we couldn’t achieve nearly soeasily without curried functions. tl;dr (Too Long;Don’t Read)curry gives you a tantalising amount of expressive power. node/npm1npm install curry","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"Thinking in Ramda 8","slug":"8-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/8-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/8-Thinking in Ramda/","excerpt":"Thinking in Ramda: LensesRamda provides a more general tool for performing the operations such as read, update, and transform object properties and array elements in a declarative, immutable way, the lens. What is a Lens?A lens combines a “getter” function and a “setter” function into a single unit. Ramda provides a set of functions for working with lenses. We can think of a lens as something that focuses on a specific part of a larger data structure. How Do I Create a Lens?The most generic way to create a lens in Ramda is with the lens function. lens takes a getter function and a setter function and returns the new lens. 12345678910111213const person = &#123; name: 'Randy', socialMedia:&#123; github: 'randycoulamn', twitter: '@randycoulman' &#125;&#125;const nameLens = lens(prop('name'), assoc('name'))const twitterLens = lens( path(['socialMedia', 'twitter']), assocPath(['socialMedia', 'twitter']))","text":"Thinking in Ramda: LensesRamda provides a more general tool for performing the operations such as read, update, and transform object properties and array elements in a declarative, immutable way, the lens. What is a Lens?A lens combines a “getter” function and a “setter” function into a single unit. Ramda provides a set of functions for working with lenses. We can think of a lens as something that focuses on a specific part of a larger data structure. How Do I Create a Lens?The most generic way to create a lens in Ramda is with the lens function. lens takes a getter function and a setter function and returns the new lens. 12345678910111213const person = &#123; name: 'Randy', socialMedia:&#123; github: 'randycoulamn', twitter: '@randycoulman' &#125;&#125;const nameLens = lens(prop('name'), assoc('name'))const twitterLens = lens( path(['socialMedia', 'twitter']), assocPath(['socialMedia', 'twitter'])) Here we’re using prop and path as our getter functions and assoc and assocPath as our setter functions. Note that we had to duplicate the property and path arguments to these functions. Fortunately， Ramda provides nice shortcuts for the most common uses of lenses：lensProp，lensPath, and lensIndex. lensProp creates a lens that focuses on a property of an object. lensPath creates a lens that focuses on a nested property of an object. lensIndex creates a lens that focuses on an element of an array. We could rewrite our lenses above with lensProp and lensPath: 12const nameLens = lensProp('name')const twitterLens = lensPath(['socialMedia', 'twitter']) What Can I Do With It?Ramda provides three functions for working with lenses. view reads the value of the lens. set updates the value of the lens. over applies a transformation funtion to the lens. 123456789101112131415161718view(nameLens, person) // =&gt;'Randy'set(twitterLens, '@randy', person)//=&gt;&#123;// name: 'Randy',// socialMedia: &#123;// github: 'randycoulman',// twitter: '@randy'// &#125;//&#125;over(nameLens, toUpper, person)// =&gt; &#123;// name: 'RANDY',// socialMedia: &#123;// github: 'randycoulman',// twitter: '@randycoulman'// &#125;//&#125; ConclusionLenses can be handy if we have a somewhat complex data structure that we want to abstract away from calling code.Rather than exposing the structure or providing a getter, setter, and transformer for every accessible property,we can instead expose lenses. Client code can the work with our data structure using view, set, and over without being coupled to the exact shape of the structrue. Cite From « Thinking in Ramda: Lenses »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Thinking in Ramda 2","slug":"2-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/2-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/2-Thinking in Ramda/","excerpt":"Thinking in Ramda: Combining funtionsSimple CombinationsOnce you’ve gotten used to the idea of passing functions to other functions, you might start to find situations where you want to combine sereral functions together. Ramda provides several functions for doing simple combinations. ComplementRamda provides a higher-order-function,complement, that takes another function and return a new function that returns true when the original function returns a falsy value, and false when the original function returns a truthy value.","text":"Thinking in Ramda: Combining funtionsSimple CombinationsOnce you’ve gotten used to the idea of passing functions to other functions, you might start to find situations where you want to combine sereral functions together. Ramda provides several functions for doing simple combinations. ComplementRamda provides a higher-order-function,complement, that takes another function and return a new function that returns true when the original function returns a falsy value, and false when the original function returns a truthy value. 12const isEven = x =&gt; x % 2 === 0find(complement(isEven), [1,2,3,4]) //--&gt; 1 Even better is to give the complemented function its own name so it can be reused: 1234const isEven = x =&gt; x % 2 ===0const isOdd = complement(isEven)find(isOdd, [1,2,3,4]) // --&gt; 1 Note that complement implements the same idea for functions as the !(not) operator does for values. BOTH/EITHERboth takes two other functions and returns a new funtion that returns true if both functions return a truthy value when applied to the arguments and false otherwise. either takes two other functions and returns a new function that returns true if either function returns a truthy value when applied to the arguments and false otherwise. Note that both implements the same idea for functions as the &amp;&amp;(and) operator does for values, and either implements that same idea for functions as the ||(or) operator does for values. Ramda also provides allPass and anyPass that take an array of any number of functions. As their names suggest, allPass works like both, and anyPass works like either. PipelinesSometimes we want to apply several functions to some data in a pipeline fashion.For example, we might want to take tow numbers,multiply them together,and one, and square the result.We could write it like this. 123456789101112const multiply = (a,b) =&gt; a*b const addOne = x =&gt; x + 1const square = x =&gt; x * xconst operate = (x, y) =&gt; &#123; const product = multiply(x,y) const incremented = addOne(product) const square = square(incremented) return squared&#125;operate(3, 4) // =&gt; ((3*4)+1)^2 ==&gt; (12 +1)^2 ==&gt; 169 PipeRamda provides the pipe functions,which takes a list of one or more functions and returns a new function. The new function takes the same number of arguments as the first function it is given.It then ‘pipes’ those arguments through each function in the list.It appliesthe first function to the arguments, passes its result to the second function and so on. The result of the last function is the result of the pipe call. Note that all of the functions after the first must only take a single argument. 12345const operate = pipe( multiply, addOne, square) Composecompose works exactly the same way as pipe, except that it applies the functions in right-to-left order instead of left-to-right. 12345const operate = compose( square, addOne, multiply) I always think of compose this way: compose(f,g)(value) is equivalent to f(g(value)). As with pipe, note that all of the functions except the last must only take a single argument. Cited From « Thinking in Ramda: Combining Functions »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Redis学习记录3","slug":"redis3","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/redis3/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/redis3/","excerpt":"Redis优化配置和redis.conf说明 redis.conf 配置参数： 12345678910111213141516171819202122#是否作为守护进程运行daemonize yes#如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pidpidfile redis.pid#绑定主机IP，默认值为127.0.0.1#bind 127.0.0.1#Redis默认监听端口port 6379#客户端闲置多少秒后，断开连接，默认为300（秒）timeout 300#日志记录等级，有4个可选值，debug，verbose（默认值），notice，warningloglevel verbose","text":"Redis优化配置和redis.conf说明 redis.conf 配置参数： 12345678910111213141516171819202122#是否作为守护进程运行daemonize yes#如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pidpidfile redis.pid#绑定主机IP，默认值为127.0.0.1#bind 127.0.0.1#Redis默认监听端口port 6379#客户端闲置多少秒后，断开连接，默认为300（秒）timeout 300#日志记录等级，有4个可选值，debug，verbose（默认值），notice，warningloglevel verbose 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#指定日志输出的文件名，默认值为stdout，也可设为/dev/null屏蔽日志logfile stdout#可用数据库数，默认值为16，默认数据库为0databases 16#保存数据到disk的策略#当有一条Keys数据被改变是，900秒刷新到disk一次save 900 1#当有10条Keys数据被改变时，300秒刷新到disk一次save 300 10#当有1w条keys数据被改变时，60秒刷新到disk一次save 60 10000#当dump.rdb数据库的时候是否压缩数据对象rdbcompression yes#本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb#本地数据库存放路径，默认值为 ./dir /var/lib/redis/########### Replication ######################Redis的复制配置# slaveof &lt;masterip&gt; &lt;masterport&gt; 当本机为从服务时，设置主服务的IP及端口# masterauth &lt;master-password&gt; 当本机为从服务时，设置主服务的连接密码#连接密码# requirepass foobared#最大客户端连接数，默认不限制# maxclients 128#最大内存使用设置，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。# maxmemory &lt;bytes&gt;#是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为noappendonly no#更新日志文件名，默认值为appendonly.aof#appendfilename#更新日志条件，共有3个可选值。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次（默认值）。# appendfsync alwaysappendfsync everysec# appendfsync no################ VIRTUAL MEMORY ############是否开启VM功能，默认值为novm-enabled no# vm-enabled yes#虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享vm-swap-file /tmp/redis.swap# 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的 (Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。vm-max-memory 0vm-page-size 32vm-pages 134217728vm-max-threads 4############# ADVANCED CONFIG ###############glueoutputbuf yeshash-max-zipmap-entries 64hash-max-zipmap-value 512#是否重置Hash表activerehashing yes 注意：Redis官方文档对VM的使用提出了一些建议: 当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大. 当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value. 最好使用linux ext3 等对稀疏文件支持比较好的文件系统保存你的swap文件. vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数.如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证. 调整系统内核参数 如果内存情况比较紧张的话，需要设定内核参数： echo 1 &gt; /proc/sys/vm/overcommit_memory 这里说一下这个配置的含义：/proc/sys/vm/overcommit_memory 该文件指定了内核针对内存分配的策略，其值可以是0、1、2。 0，表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1，表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2，表示内核允许分配超过所有物理内存和交换空间总和的内存 Redis 在dump数据的时候，会fork出一个子进程，理论上child进程所占用的内存和parent是一样的，比如parent占用的内存为 8G，这个时候也要同样分配8G的内存给child, 如果内存无法负担，往往会造成redis服务器的down机或者IO负载过高，效率下降。所以这里比较优化的内存分配策略应该设置为 1（表示内核允许分配所有的物理内存，而不管当前的内存状态如何） 一、 运行服务123# redis-server /etc/redis/redis.conf 开启# redis-cli shutdown 关闭 二、 测试 1) 可在后台启动redis服务后，用redis-benchmark命令测试 2) 通过redis-cli命令实际操作测试 三、 保存/备份 数据备份可以通过定期备份该文件实现。 因为redis是异步写入磁盘的，如果要让内存中的数据马上写入硬盘可以执行如下命令： redis-cli save 或者 redis-cli -p 6380 save（指定端口） 注意，以上部署操作需要具备一定的权限，比如复制和设定内核参数等。 执行redis-benchmark命令时也会将内存数据写入硬盘。 四、 开启端口号 1) 打开/etc/sysconfig/iptables， 2) 在-【A INPUT -p tcp -m state –state NEW -m tcp –dport 22 -j ACCEPT】后面， 加上 【-A INPUT -p tcp -m state –state NEW -m tcp –dport 6379 -j ACCEPT】 //这里的6379是Redis默认端口号 3) 保存，重启防火墙：/etc/init.d/iptables restart","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://jiaxf.github.io/tags/缓存/"}]},{"title":"函数式编程入门","slug":"fp2","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/fp2/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/fp2/","excerpt":"Functional programsPURE FUNCTIONSPure functions are functions that have no side-effects.They don&apos;t assign to any outside variables, they don&apos;t consume input, they don&apos;t produce output, they don&apos;t read from or writ to a database, they don&apos;t modify the parameters they&apos;re passed, etc. The basic idea is that, if you call a function with the same inputs over and over again, you alwyas get the same result. You can certainly do things with impure functions(and you must, if your program is going to do amything interesting), but for the most part you&apos;ll want to keep most of your funtions pure.","text":"Functional programsPURE FUNCTIONSPure functions are functions that have no side-effects.They don&apos;t assign to any outside variables, they don&apos;t consume input, they don&apos;t produce output, they don&apos;t read from or writ to a database, they don&apos;t modify the parameters they&apos;re passed, etc. The basic idea is that, if you call a function with the same inputs over and over again, you alwyas get the same result. You can certainly do things with impure functions(and you must, if your program is going to do amything interesting), but for the most part you&apos;ll want to keep most of your funtions pure. IMMUTABILITY&quot;Immutable&quot; mean &quot;unchangeable&quot;. Immutability goes hand-in-hand with pure functions. Since pure functions aren&apos;t allowed to have side-effects, they aren&apos;t allowed to change outside data structures.They are forced to work with data in an immutable way. Replace loops with collection-iteration functions（1）FOREACH 123456// replace this:for(const value of myArray)&#123; console.log(value);&#125;// with:forEach(value =&gt; console.log(value), myArray); (2) MAP Like `forEach`, `map` applies a function to each element of an array.However, unlike `forEach`, map collects the results of aaplying the function into a new array and returns it. 123456map(x =&gt; x * 2, [1,2,3]) // --&gt;[2,4,6]// orconst double = x =&gt; x * 2;map(double, [1,2,3]) (3) FILTER/REJECT 12const isEven = x =&gt; x%2 ===0filter(isEven, [1,2,3,4]) // --&gt; [2,4] filter","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"前端知识学习（摘自阮一峰博客）","slug":"javascriptIntroduce","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/javascriptIntroduce/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/javascriptIntroduce/","excerpt":"前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行","text":"前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 Model：代表业务逻辑层，它无视表现层的存在，只专注处理业务。 Controller：接受用户的输入，将输入转为相应的命令，执行进一步的操作。 View：向用户呈现展示的信息，与M建立观察者模式，根据M的改变自动重新渲染。 前端 MVP 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 前端MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：(Two-way) Data Binding 数据双向绑定。view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发”前端应用“（跑在浏览器里面的应用程序）。 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 演示 1234567891011&lt;div ng-app=\"\"&gt; &lt;p&gt; 姓名 : &lt;input type=\"text\" ng-model=\"name\" placeholder=\"在这里输入您的大名\" &gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demo/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id=\"journal\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://jiaxf.github.io/tags/node/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"}]},{"title":"Redis学习记录2","slug":"redis2","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/redis2/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/redis2/","excerpt":"redis bgrewriteaof问题一、背景 AOF: Redis的AOF机制有点类似于Mysql binlog，是Redis的提供的一种持久化方式（另一种是RDB）， 它会将所有的写命令按照一定频率(no, always, every seconds)写入到日志文件中，当Redis停机 重启后恢复数据库。","text":"redis bgrewriteaof问题一、背景 AOF: Redis的AOF机制有点类似于Mysql binlog，是Redis的提供的一种持久化方式（另一种是RDB）， 它会将所有的写命令按照一定频率(no, always, every seconds)写入到日志文件中，当Redis停机 重启后恢复数据库。 AOF重写： (1) 随着AOF文件越来越大，里面会有大部分是重复命令或者可以合并的命令（100次incr = set key 100） (2) 重写的好处：减少AOF日志尺寸，减少内存占用，加快数据库恢复时间。 二、单机多实例可能存在Swap和OOM的隐患: 由于Redis的单线程模型，理论上每个redis实例只会用到一个CPU, 也就是说可以在一台多核的服务器上 部署多个实例（实际就是这么做的）。但是Redis的AOF重写是通过fork出一个Redis进程来实现的， 所以有经验的Redis开发和运维人员会告诉你，在一台服务器上要预留一半的内存（防止出现AOF重写集 中发生，出现swap和OOM）。 三、最佳实践 1. meta信息：作为一个redis云系统，需要记录各个维度的数据，比如：业务组、机器、实例、应用、负责人多个维度的数据. 2. AOF的管理方式： (1) 自动：让每个redis决定是否做AOF重写操作（根据auto-aof-rewrite-percentage和auto-aof-rewrite-min-size两个参数） (2) crontab: 定时任务，可能仍然会出现多个redis实例，属于一种折中方案。 (3) remote集中式： 最终目标是一台机器一个时刻，只有一个redis实例进行AOF重写。 具体做法其实很简单，以机器为单位，轮询每个机器的实例，如果满足条件就运行(比如currentSize和baseSize满足什么关系)bgrewriteaof命令。 使用client list命令（类似于mysql processlist） redis-cli -h host -p port client list | grep -v “omem=0”，来查询输出缓冲区不为0的客户端连接 1redis-cli -h 127.0.0.1 -p 6379 client list 四、紧急处理和解决方法 进行主从切换（主从内存使用量不一致），也就是redis-cluster的fail-over操作，继续观察新的 Master是否有异常，通过观察未出现异常。 查找到真正的原因后，也就是monitor，关闭掉monitor命令的进程后，内存很快就降下来了。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://jiaxf.github.io/tags/缓存/"}]},{"title":"javascript模式","slug":"jsPattern","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/jsPattern/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/jsPattern/","excerpt":"javascriptPattern《javascript设计模式与开发实践》学习记录 模式 什么是模式模式是一个可复用的解决方案，可用于解决软件设计中的常见问题。三大好处： 模式是已验证的解决方案 模式很容易被复用 模式富有表达力 优秀的模式优秀的模式应当可以执行以下操作： 解决特殊问题 没有显而易见的解决方案 描述经过验证的概念 描述一种关系 设计模式的类别","text":"javascriptPattern《javascript设计模式与开发实践》学习记录 模式 什么是模式模式是一个可复用的解决方案，可用于解决软件设计中的常见问题。三大好处： 模式是已验证的解决方案 模式很容易被复用 模式富有表达力 优秀的模式优秀的模式应当可以执行以下操作： 解决特殊问题 没有显而易见的解决方案 描述经过验证的概念 描述一种关系 设计模式的类别 创建型设计模式专注语处理对象创建机制，以合适给定情况的方式来创建对象。包括： Constructor构造器 Factory工厂 Abstract抽象 Prototype原型 Singleton单例 Builder生成器 结构型设计模式结构型设计模式与组合对象有关，通常可以用于找出在不同对象之间建立关系的简单方法。这种模式有助于确保系统某一部分改变时，不会影响到整体结构，同时改变后能较好地重组。包括： Decorator装饰者 Facade外观 Flyweight享元 Adapter适配器 Proxy代理 行为设计模式专注语改善或简化系统中不同对象之间的通信，包括： Iterator迭代器 Mediator终结者 Observer观察者 Visitor访问者","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"pattern","slug":"pattern","permalink":"http://jiaxf.github.io/tags/pattern/"}]},{"title":"Redis学习记录","slug":"redis","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/redis/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/redis/","excerpt":"Redis学习记录业界常用的一些 key-value分布式缓存系统如下： Redis Memcached Cassandra（Facebook 开源） Tokyo Tyrant (Tokyo Cabinet) Redis的几个特点： Redis 是一个 key-value 的缓存(cache)和存储(store)系统（适合作缓存或DB） 支持丰富的数据结构 List 就专门用于存储列表型数据，默认按操作时间排序 Sorted Set 可以按分数排序元素，分数是一种广义概念，可以是时间或评分 其丰富的数据结构为日后扩展提供了很大的方便。 提供的所有操作都是原子操作，为并发天然保驾护航。 超快的性能，见其官方性能测试《How fast is Redis?》。 拥有比较成熟的Java客户端 - Jedis，像新浪微博都是使用它作为客户端。（官方推荐的Clients）","text":"Redis学习记录业界常用的一些 key-value分布式缓存系统如下： Redis Memcached Cassandra（Facebook 开源） Tokyo Tyrant (Tokyo Cabinet) Redis的几个特点： Redis 是一个 key-value 的缓存(cache)和存储(store)系统（适合作缓存或DB） 支持丰富的数据结构 List 就专门用于存储列表型数据，默认按操作时间排序 Sorted Set 可以按分数排序元素，分数是一种广义概念，可以是时间或评分 其丰富的数据结构为日后扩展提供了很大的方便。 提供的所有操作都是原子操作，为并发天然保驾护航。 超快的性能，见其官方性能测试《How fast is Redis?》。 拥有比较成熟的Java客户端 - Jedis，像新浪微博都是使用它作为客户端。（官方推荐的Clients） 12# 查看redis的连接数sudo netstat -antp | grep 6379 | wc -l 注意：redis关闭集群链接时异常导致连接泄漏 1234567redis.max.idle.num=32768redis.min.idle.num=30redis.pool.behaviour=LIFOredis.time.between.eviction.runs.seconds=1redis.num.tests.per.eviction.run=10redis.min.evictable.idle.time.minutes=5redis.max.evictable.idle.time.minutes=30 LIFO“后进先出”栈方式 有效地利用了空闲队列里的热点池对象资源，随着流量的下降会使一些池对象长时间未被使用而空闲着，最终它们将被淘汰驱逐； 而 FIFO“先进先出”队列方式 虽然使空闲队列里所有池对象都能在一段时间里被使用，看起来它好像分散了资源的请求，但其实这不利于资源的释放。而这也是“客户端连接数一直降不下来”的根源之一。 结论： 1. 对象池的空闲队列行为（采用LIFO“后进先出”栈方式） 2. 注意关闭集群链接时异常导致连接泄漏","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://jiaxf.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://jiaxf.github.io/tags/缓存/"}]},{"title":"MySQL双主一致性架构优化","slug":"mysqlMySQL双主一致性架构优化","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/mysqlMySQL双主一致性架构优化/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/mysqlMySQL双主一致性架构优化/","excerpt":"MySQL双主一致性架构优化一、双主保证高可用 MySQL数据库集群常使用一主多从，主从同步，读写分离的方式来扩充数据库的读性能，保证读库的高可用，但此时写库仍然是单点。 在一个MySQL数据库集群中可以设置两个主库，并设置双向同步，以冗余写库的方式来保证写库的高可用。 二、并发引发不一致 数据冗余会引发数据的一致性问题，因为数据的同步有一个时间差，并发的写入可能导致数据同步失败，引起数据丢失： 如上图所述，假设主库使用了auto increment来作为自增主键： 两个MySQL-master设置双向同步可以用来保证主库的高可用 数据库中现存的记录主键是1，2，3 主库1插入了一条记录，主键为4，并向主库2同步数据 数据同步成功之前，主库2也插入了一条记录，由于数据还没有同步成功，插入记录生成的主键也为4，并向主库1也同步数据 主库1和主库2都插入了主键为4的记录，双主同步失败，数据不一致","text":"MySQL双主一致性架构优化一、双主保证高可用 MySQL数据库集群常使用一主多从，主从同步，读写分离的方式来扩充数据库的读性能，保证读库的高可用，但此时写库仍然是单点。 在一个MySQL数据库集群中可以设置两个主库，并设置双向同步，以冗余写库的方式来保证写库的高可用。 二、并发引发不一致 数据冗余会引发数据的一致性问题，因为数据的同步有一个时间差，并发的写入可能导致数据同步失败，引起数据丢失： 如上图所述，假设主库使用了auto increment来作为自增主键： 两个MySQL-master设置双向同步可以用来保证主库的高可用 数据库中现存的记录主键是1，2，3 主库1插入了一条记录，主键为4，并向主库2同步数据 数据同步成功之前，主库2也插入了一条记录，由于数据还没有同步成功，插入记录生成的主键也为4，并向主库1也同步数据 主库1和主库2都插入了主键为4的记录，双主同步失败，数据不一致 三、相同步长免冲突 能否保证两个主库生成的主键一定不冲突呢？回答： 设置不同的初始值 设置相同的增长步长 就能够做到。 如上图所示：两个MySQL-master设置双向同步可以用来保证主库的高可用 库1的自增初始值是1，库2的自增初始值是2，增长步长都为2 库1中插入数据主键为1/3/5/7，库2中插入数据主键为2/4/6/8，不冲突 数据双向同步后，两个主库会包含全部数据 如上图所示，两个主库最终都将包含1/2/3/4/5/6/7/8所有数据，即使有一个主库挂了，另一个主库也能够保证写库的高可用。 四、上游生成ID避冲突 换一个思路，为何要依赖于数据库的自增ID，来保证数据的一致性呢？完全可以由业务上游，使用统一的ID生成器，来保证ID的生成不冲突： 如上图所示，调用方插入数据时，带入全局唯一ID，而不依赖于数据库的auto increment，也能解决这个问题。 至于如何生成全局唯一，趋势递增的ID，参见文章《分布式ID生成算法》。 五、消除双写不治本 使用auto increment两个主库并发写可能导致数据不一致，只使用一个主库提供服务，另一个主库作为shadow-master，只用来保证高可用，能否避免一致性问题呢？ 如上图所示： 两个MySQL-master设置双向同步可以用来保证主库的高可用 只有主库1对外提供写入服务 两个主库设置相同的虚IP，在主库1挂掉或者网络异常的时候，虚IP自动漂移，shadow master顶上，保证主库的高可用 这个切换由于虚IP没有变化，所以切换过程对调用方是透明的，但在极限的情况下，也可能引发数据的不一致： 如上图所示： 两个MySQL-master设置双向同步可以用来保证主库的高可用，并设置了相同的虚IP 网络抖动前，主库1对上游提供写入服务，插入了一条记录，主键为4，并向shadow master主库2同步数据 突然主库1网络异常，keepalived检测出异常后，实施虚IP漂移，主库2开始提供服务 在主键4的数据同步成功之前，主库2插入了一条记录，也生成了主键为4的记录，结果导致数据不一致 六、内网DNS探测 虚IP漂移，双主同步延时导致的数据不一致，本质上，需要在双主同步完数据之后，再实施虚IP偏移，使用内网DNS探测，可以实现shadow master延时高可用：使用内网域名连接数据库，例如：db.58daojia.org主库1和主库2设置双主同步，不使用相同虚IP，而是分别使用ip1和ip2一开始db.58daojia.org指向ip1用一个小脚本轮询探测ip1主库的连通性当ip1主库发生异常时，小脚本delay一个x秒的延时，等待主库2同步完数据之后，再将db.58daojia.org解析到ip2程序以内网域名进行重连，即可自动连接到ip2主库，并保证了数据的一致性 七、总结 主库高可用，主库一致性，一些小技巧： 双主同步是一种常见的保证写库高可用的方式 设置相同步长，不同初始值，可以避免auto increment生成冲突主键 不依赖数据库，业务调用方自己生成全局唯一ID是一个好方法 shadow master保证写库高可用，只有一个写库提供服务，并不能完全保证一致性 内网DNS探测，可以实现在主库1出现问题后，延时一个时间，再进行主库切换，以保证数据一致性","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiaxf.github.io/tags/mysql/"}]},{"title":"mysql调优","slug":"mysql调优","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/mysql调优/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/mysql调优/","excerpt":"MySQL 调优mysql中的两个关键参数(1)interactive_timeout: 参数含义：服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。参数默认值：28800秒（8小时） (2)wait_timeout: 参数含义：服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时） wait_timeout过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能，不过也不能把这个指设置的过小，否则你可 能会遭遇到“MySQL has gone away”之类的问题，通常来说，我觉得把wait_timeout设置为10是个不错的选择，但某些情况下可能也会出问题，比如说有一个CRON脚本， 其中两次SQL查询的间隔时间大于10秒的话，那么这个设置就有问题了（当然，这也不是不能解决的问题，你可以在程序里时不时mysql_ping一下， 以便服务器知道你还活着，重新计算wait_timeout时间）","text":"MySQL 调优mysql中的两个关键参数(1)interactive_timeout: 参数含义：服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。参数默认值：28800秒（8小时） (2)wait_timeout: 参数含义：服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时） wait_timeout过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能，不过也不能把这个指设置的过小，否则你可 能会遭遇到“MySQL has gone away”之类的问题，通常来说，我觉得把wait_timeout设置为10是个不错的选择，但某些情况下可能也会出问题，比如说有一个CRON脚本， 其中两次SQL查询的间隔时间大于10秒的话，那么这个设置就有问题了（当然，这也不是不能解决的问题，你可以在程序里时不时mysql_ping一下， 以便服务器知道你还活着，重新计算wait_timeout时间） set global wait_timeout12 mysqladmin -uroot -ppassword variables|grep _cache[mysqld]# * Basic Settings#user = mysqlsocket = /var/run/mysqld/mysqld.sockport = 3306basedir = /usrdatadir = /var/lib/mysqlpid-file = /var/run/mysqld/mysqld.pidtmpdir = /tmplc-messages-dir = /usr/share/mysql #binlog的名字最好不要为默认，这样便于数据库的移植 #造成睡眠连接过多的原因？ #1.使用了太多持久连接（个人觉得，在高并发系统中，不适合使用持久连接） #2.程序中，没有及时关闭mysql连接 #3.数据库查询不够优化，过度耗时wait_timeout=300interactive_timeout=300 #MySQL允许最大连接数max_connections = 5000 #可以允许多少个错误连接max_connect_errors = 6000 #忽略大小写lower_case_table_names = 1 #避免Mysql的外部锁定，减少出错几率增加稳定性 #当外部锁定（external-locking）起作用时，每个进程若要访问数据表，则必须等待之前的进程完成操作并解除锁定。 #由于服务器访问数据表时经常需要等待解锁，因此在单服务器环境下external locking会让MySQL性能下降。 #所以在很多Linux发行版的源中，MySQL配置文件中默认使用了skip-external-locking来避免external locking。 #当使用了skip-external-locking后，为了使用MyISAMChk检查数据库或者修复、优化表，你必须保证在此过程中MySQL服务器没有使用需要操作的表。 #如果没有停止服务器，也至少需要先运行 #mysqladmin flush-tables #详见http://www.bootf.com/594.htmlskip-external-locking #禁止mysql对外部链接进行DNS解析，使用这一选项可以消除Mysql进行DNS解析的时间,但需要注意， #如果开启该选项，则所有远程主机连接授权都要使用IP地址的方式没,否则Mysql将无法正常处理连接请求!skip-name-resolve #指定MySQL可能的连接数量。当MySQL主线程在很短的时间内接收到非常多的连接请求，该参数生效，主线程花费很短的时间检查连接并且启动一个新线程。 #back_log 参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。 #如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。 #不同的操作系统在这个队列大小上有它自己的限制。 #试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数 #在linux下这个参数的值不能大于系统参数tcp_max_syn_backlog的值。 #通过以下命令可以查看tcp_max_syn_backlog的当前值 cat /proc/sys/net/ipv4/tcp_max_syn_backlog。 #我将该值设为300，作为测试 #mysql&gt; show variables like ‘back_log’;back_log=300 wait_timeout=181440# Instead of skip-networking the default is now to listen only onlocalhost which is more compatible and is not less secure.#bind-address = 129.0.0.124# * Fine Tuning# #索引块是缓冲的并且被所有的线程共享。key_buffer_size是用于索引块的缓冲区大小， #增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大， #系统将开始换页并且真的变慢了。 #http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html #You can increase the value to get better index handling for all reads and multiple writes; #on a system whose primary function is to run MySQL using the MyISAM storage engine, #25% of the machine’s total memory is an acceptable value for this variable. #mysql&gt; show variables like ‘key_buffer%’key_buffer_size = 1Gmax_allowed_packet = 128M #The stack size for each thread. Many of the limits detected by the crash-me test are dependent on this value. #The default of 192KB (256KB for 64-bit systems) is large enough for normal operation. #If the thread stack size is too small, it limits the complexity of the SQL statements that the server can handle, #the recursion depth of stored procedures, and other memory-consuming actions. #http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.htmlthread_stack = 256K #服务器线程缓存thread_cache_size没有进行设置，或者设置过小,这个值表示可以重新利用保存在缓存中线程的数量, #当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取, #如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能. #通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)根据物理内存设置规则如下： #1G —&gt; 8 #2G —&gt; 16 #3G —&gt; 32 #&gt;3G —&gt; 64thread_cache_size = 64 #为了更快的open表，这个参数很重要；比如200个并发connection，table_open_cache=200×N（一个查询中参与join的最大表的数量，也可能是分区表），如果是myisam表的话，table_open_cache=200×(N×2),还要考虑突发的临时表的文件描述符；在os可以支持打开文件数时，如果table_open_cache设置的比较高，mysql用光所有的文件描述符，就会拒绝连 #，查询出错.table_open_cache设置多大合适呢？处理从上面的理论推理计算外，还可以根据状态变量来监控“Opened_tables”，这个状态变量表示，从server服务启动为止，open表的数量，可以根据这个状态变量来比较精准的设置table_oprn_cache #暂时设定为1024，需要有大规模考试测试做依据 #show global status like ‘%open%table%’table_open_cache = 1024 Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。#Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。例如：500个连接将会消耗 500*sort_buffer_size(8M)=4G内存 #Sort_Buffer_Size 超过2KB的时候，就会使用mmap() 而不是 malloc() 来进行内存分配，导致效率降低。 #技术导读 http://blog.webshuo.com/2011/02/16/mysql-sort_buffer_size/ #dev-doc: http://dev.mysql.com/doc/refman/5.5/en/server-parameters.html #explain select*from table where order limit；出现filesort #属重点优化参数sort_buffer_size = 16M #用于表间关联缓存的大小join_buffer_size = 16M MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。如果对表的顺序扫&gt;描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。read_buffer_size = 32M MySql的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁&gt;盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过&gt;大。read_rnd_buffer_size = 32M MyISAM表发生变化时重新排序所需的缓冲myisam_sort_buffer_size = 128M This replaces the startup script and checks MyISAM tables if neededthe first time they are touchmyisam-recover = BACKUP #max_connections = 100 #table_cache = 64 #thread_concurrency = 10# * Query Cache Configuration#允许cache 的单条 Query 结果集的最大容量，默认是1MB，超过此参数设置的 Query 结果集将不会被 Cachequery_cache_limit = 4M #设置Query Cache所使用的内存大小，默认值为0，大小必须是1024的整数倍，如果不是整数倍，MySQL 会自动调整降低最小量以达到1024的倍数。 #当我们打开了 Query Cache功能，MySQL在接受到一条select语句的请求后，如果该语句满足Query Cache的要求 #(未显式说明不允许使用Query Cache，或者已经显式申明需要使用Query Cache)， #MySQL会直接根据预先设定好的HASH算法将接受到的select语句以字符串方式进行hash，然后到Query Cache中直接查找是否已经缓存。 #也就是说，如果已经在缓存中，该select请求就会直接将数据返回， #从而省略了后面所有的步骤(如SQL语句的解析，优化器优化以及向存储引擎请求数据等)，极大的提高性能。 #当然，Query Cache也有一个致命的缺陷，那就是当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。 #所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。 #以往的经验来看，如果不是用来缓存基本不变的数据的MySQL数据库，query_cache_size一般256MB是一个比较合适的大小。 #当然，这可以通过计算Query Cache的命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))来进行调整。 #这里我设置为512Ｍ需要具体测试结果来查看最后Querycache的命中率 #http://www.csdn.net/article/2011-10-28/306555query_cache_size = 512M # * Logging and Replication# Both location gets rotated by the cronjob.Be aware that this log type is a performance killer.As of 5.1 you can enable the log at runtime!#general_log_file = /var/log/mysql/mysql.log #general_log = 1# Error logging goes to syslog due to /etc/mysql/conf.d/mysqld_safe_syslog.cnf.Here you can see queries with especially long duration#log_slow_queries = /usr/local/mysql5/log/mysql-slow.log #默认设置为2表示执行时间超过2秒的都算慢查询(itest中是否有过多的慢查询，开启log文件后可看到具体的详细信息long_query_time = 4log_error = /var/log/mysql/error.log #log-queries-not-using-indexes# The following can be used as easy to replay backup logs or for replication.note: if you are setting up a replication slave, see README.Debian aboutother settings you may need to change.#For mysql Master and Slaveserver-id = 56 #binlog的名字最好不要为默认，这样便于数据库的移植 #log-bin = /usr/local/mysql5/log/mysql-bin.log #relay_log = /usr/local/mysql5/log/relay-bin #skip_slave_start #read_onlyexpire_logs_days = 10max_binlog_size = 100M #############I##nnoDB部分################## #完整的InnoDB优化方案:http://www.mysqlperformanceblog.com/2007/11/01/innodb-performance-optimization-basics/ #http://swachian.iteye.com/blog/193788 #抱怨Innodb比MyISAM慢100倍？那么你大概是忘了调整这个值。 #默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。 #特别是使用电池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM表转过来的是可以的， #它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到硬 盘，所以你一般不会丢失超过1-2秒的更新。 #设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统挂了时才可能丢数据。innodb_flush_log_at_trx_commit=0 Set buffer pool size to 50-80% of your computer’s memory#针对服务器学校服务器比较烂的原因，我选择4Ｇ内存作为基准 #高过1Ｇ启动不了innodb_buffer_pool_size=8G #http://www.cnblogs.com/zuoxingyu/archive/2012/10/25/2738864.htmlinnodb_log_file_size= 64Minnodb_log_buffer_size = 16M 附加的内存池被InnoDB用来保存 metadata 信息如果InnoDB为此目的需要更多的内存,它会开始从OS这里申请内存.由于这个操作在大多数现代操作系统上已经足够快, 你一般不需要修改此值.SHOW INNODB STATUS 命令会显示当先使用的数量.根据表的多少来确定大小，一般16M己能适用于几百个表#innodb_additional_mem_pool_size=16M 在InnoDb核心内的允许线程数量.最优值依赖于应用程序,硬件以及操作系统的调度方式.过高的值可能导致线程的互斥颠簸.#innodb_thread_concurrency=8 #Avoid double buffering and reduce swap pressure, in most cases this setting improves performance. #Though be careful if you do not have battery backed up RAID cache as when write IO may suffer. #在Linux上使用Direct IO。可以显著提高速度，特别是在RAID系统上。避免额外的数据复制和double buffering（mysql buffering 和OS buffering）。innodb_flush_method=O_DIRECT Buffer_Pool中Dirty_Page所占的数量，直接影响InnoDB的关闭时间。参数innodb_max_dirty_pages_pct可以直接控制了Dirty_Page在Buffer_Pool中所占的比率，而且幸运的是innodb_max_dirty_pages_pct是可以动态改变的。所以，在关闭InnoDB之前先将innodb_max_dirty_pages_pct调小，强制数据块Flush一段时间，则能够大大缩&gt;短MySQL关闭的时间&gt;。innodb_max_dirty_pages_pct = 90 12 back_log = 600 #在MYSQL暂时停止响应新请求之前，短时间内的多少个请求可以被存在堆栈中。如果系统在短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的监听队列的大小。默认值50。 max_connections = 3000 #MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。 max_connect_errors = 6000 #设置每个主机的连接请求异常中断的最大次数，当超过该次数，MYSQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息。 table_cache = 614 #指示表调整缓冲区大小。# table_cache 参数设置表高速缓存的数目。每个连接进来，都会至少打开一个表缓存。#因此， table_cache 的大小应与 max_connections 的设置有关。例如，对于 200 个#并行运行的连接，应该让表的缓存至少有 200 × N ，这里 N 是应用可以执行的查询#的一个联接中表的最大数量。此外，还需要为临时表和文件保留一些额外的文件描述符。 当 Mysql 访问一个表时，如果该表在缓存中已经被打开，则可以直接访问缓存；如果#还没有被缓存，但是在 Mysql 表缓冲区中还有空间，那么这个表就被打开并放入表缓#冲区；如果表缓存满了，则会按照一定的规则将当前未用的表释放，或者临时扩大表缓存来存放，使用表缓存的好处是可以更快速地访问表中的内容。执行 flush tables 会#清空缓存的内容。一般来说，可以通过查看数据库运行峰值时间的状态值 Open_tables #和 Opened_tables ，判断是否需要增加 table_cache 的值（其中 open_tables 是当#前打开的表的数量， Opened_tables 则是已经打开的表的数量）。即如果open_tables接近table_cache的时候，并且Opened_tables这个值在逐步增加，那就要考虑增加这个#值的大小了。还有就是Table_locks_waited比较高的时候，也需要增加table_cache。external-locking = FALSE #使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启 max_allowed_packet = 32M #设置在网络传输中一次消息传输量的最大值。系统默认值 为1MB，最大值是1GB，必须设置1024的倍数。 sort_buffer_size = 2M Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。#Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。例如：500个连接将会消耗 500*sort_buffer_size(8M)=4G内存 #Sort_Buffer_Size 超过2KB的时候，就会使用mmap() 而不是 malloc() 来进行内存分配，导致效率降低。 #技术导读 http://blog.webshuo.com/2011/02/16/mysql-sort_buffer_size/ #dev-doc: http://dev.mysql.com/doc/refman/5.5/en/server-parameters.html #explain select*from table where order limit；出现filesort #属重点优化参数 join_buffer_size = 2M #用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。 thread_cache_size = 300 服务器线程缓存这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。设置规则如下：1GB 内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。thread_concurrency = 8 设置thread_concurrency的值的正确与否, 对mysql的性能影响很大, 在多个cpu(或多核)的情况下，错误设置了thread_concurrency的值, 会导致mysql不能充分利用多cpu(或多核), 出现同一时刻只能一个cpu(或核)在工作的情况。thread_concurrency应设为CPU核数的2倍. 比如有一个双核的CPU, 那么thread_concurrency的应该为4; 2个双核的cpu, thread_concurrency的值应为8#属重点优化参数 query_cache_size = 64M 对于使用MySQL的用户，对于这个变量大家一定不会陌生。前几年的MyISAM引擎优化中，这个参数也是一个重要的优化参数。但随着发展，这个参数也爆露出来一些问题。机器的内存越来越大，人们也都习惯性的把以前有用的参数分配的值越来越大。这个参数加大后也引发了一系列问题。我们首先分析一下 query_cache_size的工作原理：一个SELECT查询在DB中工作后，DB会把该语句缓存下来，当同样的一个SQL再次来到DB里调用时，DB在该表没发生变化的情况下把结果从缓存中返回给Client。这里有一个关建点，就是DB在利用Query_cache工作时，要求该语句涉及的表在这段时间内没有发生变更。那如果该表在发生变更时，Query_cache里的数据又怎么处理呢？首先要把Query_cache和该表相关的语句全部置为失效，然后在写入更新。那么如果Query_cache非常大，该表的查询结构又比较多，查询语句失效也慢，一个更新或是Insert就会很慢，这样看到的就是Update或是Insert怎么这么慢了。所以在数据库写入量或是更新量也比较大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。#重点优化参数（主库 增删改-MyISAM） query_cache_limit = 4M #指定单个查询能够使用的缓冲区大小，缺省为1M query_cache_min_res_unit = 2k #默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费 #查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100% #如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。 #查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100% #查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。 #查询缓存命中率 = (Qcache_hits – Qcache_inserts) / Qcache_hits * 100% default-storage-engine = MyISAM #default_table_type = InnoDB thread_stack = 192K #设置MYSQL每个线程的堆栈大小，默认值足够大，可满足普通操作。可设置范围为128K至4GB，默认为192KB。 transaction_isolation = READ-COMMITTED 设定默认的事务隔离级别.可用的级别如下:READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE1.READ UNCOMMITTED-读未提交2.READ COMMITTE-读已提交3.REPEATABLE READ -可重复读4.SERIALIZABLE -串行tmp_table_size = 256M tmp_table_size 的默认大小是 32M。如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你做很多高级 GROUP BY 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。max_heap_table_size = 256Mlong_query_time = 2log_long_formatlog-slow-queries=/data/3306/slow-log.log #log-bin = /data/3306/mysql-binlog-binbinlog_cache_size = 4Mmax_binlog_cache_size = 8Mmax_binlog_size = 512M expire_logs_days = 7key_buffer_size = 2048M #批定用于索引的缓冲区大小，增加它可以得到更好的索引处理性能，对于内存在4GB左右的服务器来说，该参数可设置为256MB或384MB。 read_buffer_size = 1M MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。read_rnd_buffer_size = 16M MySql的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。bulk_insert_buffer_size = 64M #批量插入数据缓存大小，可以有效提高插入效率，默认为8M myisam_sort_buffer_size = 128M MyISAM表发生变化时重新排序所需的缓冲myisam_max_sort_file_size = 10G MySQL重建索引时所允许的最大临时文件的大小 (当 REPAIR, ALTER TABLE 或者 LOAD DATA INFILE).如果文件大小比此值更大,索引会通过键值缓冲创建(更慢)myisam_max_extra_sort_file_size = 10Gmyisam_repair_threads = 1 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.这对于拥有多个CPU以及大量内存情况的用户,是一个很好的选择.myisam_recover #自动检查和修复没有适当关闭的 MyISAM 表skip-name-resolvelower_case_table_names = 1 server-id = 1 innodb_additional_mem_pool_size = 16M #这个参数用来设置 InnoDB 存储的数据目录信息和其它内部数据结构的内存池大小，类似于Oracle的library cache。这不是一个强制参数，可以被突破。 innodb_buffer_pool_size = 2048M 这对Innodb表来说非常重要。Innodb相比MyISAM表对缓冲更为敏感。MyISAM可以在默认的 key_buffer_size 设置下运行的可以，然而Innodb在默认的 innodb_buffer_pool_size 设置下却跟蜗牛似的。由于Innodb把数据和索引都缓存起来，无需留给操作系统太多的内存，因此如果只需要用Innodb的话则可以设置它高达 70-80% 的可用内存。一些应用于 key_buffer 的规则有 — 如果你的数据量不大，并且不会暴增，那么无需把 innodb_buffer_pool_size 设置的太大了innodb_data_file_path = ibdata1:1024M:autoextend #表空间文件 重要数据 innodb_file_io_threads = 4 #文件IO的线程数，一般为 4，但是在 Windows 下，可以设置得较大。 innodb_thread_concurrency = 8 #服务器有几个CPU就设置为几，建议用默认设置，一般为8. innodb_flush_log_at_trx_commit = 2 如果将此参数设置为1，将在每次提交事务后将日志写入磁盘。为提供性能，可以设置为0或2，但要承担在发生故障时丢失数据的风险。设置为0表示事务日志写入日志文件，而日志文件每秒刷新到磁盘一次。设置为2表示事务日志将在提交时写入日志，但日志文件每次刷新到磁盘一次。innodb_log_buffer_size = 16M #此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据.MySQL开发人员建议设置为1－8M之间 innodb_log_file_size = 128M #此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间 innodb_log_files_in_group = 3 #为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3M innodb_max_dirty_pages_pct = 90 #推荐阅读 http://www.taobaodba.com/html/221_innodb_max_dirty_pages_pct_checkpoint.html Buffer_Pool中Dirty_Page所占的数量，直接影响InnoDB的关闭时间。参数innodb_max_dirty_pages_pct 可以直接控制了Dirty_Page在Buffer_Pool中所占的比率，而且幸运的是innodb_max_dirty_pages_pct是可以动态改变的。所以，在关闭InnoDB之前先将innodb_max_dirty_pages_pct调小，强制数据块Flush一段时间，则能够大大缩短 MySQL关闭的时间。innodb_lock_wait_timeout = 120 InnoDB 有其内置的死锁检测机制，能导致未完成的事务回滚。但是，如果结合InnoDB使用MyISAM的lock tables 语句或第三方事务引擎,则InnoDB无法识别死锁。为消除这种可能性，可以将innodb_lock_wait_timeout设置为一个整数值，指示 MySQL在允许其他事务修改那些最终受事务回滚的数据之前要等待多长时间(秒数)innodb_file_per_table = 0 #独享表空间（关闭） [mysqldump]quickmax_allowed_packet = 32M [mysqld_safe]log-error=/data/3306/mysql_oldboy.errpid-file=/data/3306/mysqld.pid #补充 #wait_timeout = 10 #指定一个请求的最大连接时间，对于4GB左右的内存服务器来说，可以将其设置为5-10。 #skip_networking #开启该选可以彻底关闭MYSQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MYSQL数据库服务器的，则不要开启该选项，否则将无法正常连接。 #log-queries-not-using-indexes将没有使用索引的查询也记录下来 `","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jiaxf.github.io/tags/mysql/"}]},{"title":"Thinking in Ramda 1","slug":"1-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/1-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/1-Thinking in Ramda/","excerpt":"Thinking in Ramda: getting startedGetting StartedI’ll be using the Ramda JavaScript library fro this series,though many of the ideas apply to other JavaScript libraries such as Underscore and Lodash as well as to other languages. I’m going to stick to the lighter,less-academic end of functional programing. RamdaI find Ramda to be a nicely designed library that provides a lot of tools for doing functional programming in JavaScript in a clean, elegant way.","text":"Thinking in Ramda: getting startedGetting StartedI’ll be using the Ramda JavaScript library fro this series,though many of the ideas apply to other JavaScript libraries such as Underscore and Lodash as well as to other languages. I’m going to stick to the lighter,less-academic end of functional programing. RamdaI find Ramda to be a nicely designed library that provides a lot of tools for doing functional programming in JavaScript in a clean, elegant way. FunctionsSome languages go further and provide support for functions as first-class constructs. By “first-class”, I mean that functions can be used in the same way as other kinds of values.You can: refer to them from constants and variables pass them as parameters to other Functions return them as results from other Functions JavaScript is one such language, and we’ll be taking advantage of that. Pure FunctionsPure functions are functions that have no side-effects.They don’t assign to any outside variables,they don’t consume input, they don’t produce output,they don’t read from or write to a database,they don’t modify the parameters they’re passed,etc. The basic idea is that,if you call a function with the same inputs over and over again,you always get the same result. You can certainly do things with impure functions(and you must, if you program is going to do anything interesting), but for the most part you’ll want to keep most of you functions pure. ImmutabilityWhat dose that mean? “Immutable” means “unchangeable”. When I’m working in an immutable fashion, once I initialize a value or an object I never change it again.That means no changing elements of an array or properties of an object. If I need to change something in an array or object,I instead return a new copy of it with the changed value. Later posts will talk about this in great detail. Immutability goes hand-in-hand with pure functions.Since pure functions aren’t allowed to have side-effects, they aren’t allowed to change outside data structures.They are forced to work with data in an immutable way. FOREACHRather than writing an explicit loop,try using the forEach function instead.That is: 123456//Replace thisfor ( const value of myArray)&#123; console.log(value)&#125;//WithforEach(value =&gt; console.log(value), myArray) forEach takes a function an d an array, and calls the function on each element of the array. MAPUnlike forEach, map collects the results of applying the function into a new array and returns it. 1234map(x =&gt; x *2, [1,2,3]) // =&gt;[2,4,6]const double = x =&gt; x * 2map(double, [1,2,3]) // =&gt;[2,4,6] FILTER/REJECTAs its name might suggest, filter selects elements from an array based on some function.reject does exactly the same thing, but in reverse. It keeps the elements for which the function returns a false value and excludes the values for which it returns a truthy value. 1234const isEven = x =&gt; x%2 === 0filter(isEven, [1,23,4]) // ==&gt; [2, 4]reject(isEven, [1,2,3,4]) // ==&gt; [1,3] FINDfind applies a function to each element of an array and returns the first element for which the function returns a truthy value. 1find(isEven, [1,2,3,4]) // --&gt; 2 REDUCEreduce takes a two-argument function, and initial value,and the array to operate on. The first argument to the function we pass in is called the “accumulator” and the second argument is the value from the array.The function needs to return a new accumulator value. 12const add = (accum, value) =&gt; accum + valuereduce(add, 5, [1,2,3,4]) // --&gt; 15 ConclusionBy starting with these collection-iteration functions, you can get used to the idea of passing functions to other functions. You might have used these in other languages without realizing you were doing some functional programming. Cited From « Thinking in Ramda: Getting Started »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"Thinking in Ramda 3","slug":"3-Thinking in Ramda","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/3-Thinking in Ramda/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/3-Thinking in Ramda/","excerpt":"Thinking in Ramda: Partial ApplicationHigher-Order FunctionsFunctions that take or return other functions are known as “higher-order functions”. 1234567891011121314// Full function version:function publishedInYear(year) &#123; return function(book)&#123; return book.year === year &#125;&#125;// Arrow function version:const publishedInYear = year =&gt; book =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; &#123; const selected = filter(publishedInYear(year), books) return map(book =&gt; book.title, selected)&#125;","text":"Thinking in Ramda: Partial ApplicationHigher-Order FunctionsFunctions that take or return other functions are known as “higher-order functions”. 1234567891011121314// Full function version:function publishedInYear(year) &#123; return function(book)&#123; return book.year === year &#125;&#125;// Arrow function version:const publishedInYear = year =&gt; book =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; &#123; const selected = filter(publishedInYear(year), books) return map(book =&gt; book.title, selected)&#125; Partially-Applying functionsWe could rewrite any multi-argument function this way if we wanted to, but we don’t own all of the functions we might want to use. Also, we might want to use some multi-argument functions in the usual way. Ramda provides two functions to help us out: partial, and partialRight. These two functions let us call any function with fewer arguments than it needs. They both return a new function that takes the missing arguments and then calls the original function once all of the arguments have been supplied. The difference between partial and partialRight is whether the arguments we supply are the left-most or right-most arguments needed by the original function. Note that the arguments we supply to partial and partialRight must always be in an array, even if there’s only one of them. 1234567const publishedInYear = (book, year) =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; &#123; const selected = filter(partialRight(publishedInYear, [year]), books) return map(book =&gt; book.title, selected)&#125; CurryCurrying is another core concept in functional programming. Technically, a curried function is always a series of single-argument functions, which is what I was just complaining about. In pure functional languages, the syntax generally makes that look no different than calling a function with multiple arguments. 柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。“如果固定某些参数，将会得到余下参数的一个函数”。 函数柯里化的对偶是Uncurrying,一种是使用匿名单参数函数来实现多参数函数的方法。 1234567var foo = function(a)&#123; return function(b)&#123; return a*a + b*b; &#125;&#125;(foo(3))(4) or foo(3)(4) 惰性求值（Lazy Evaluation），又称惰性计算、懒惰求值，也称为传需求调用（call-by-need）。它的目的是要最小化计算机要做的工作。除可以得到性能的提升外，惰性计算的最重要的好处是它可以构造一个无限的数据类型或可计算的无限列表而没有妨碍计算的无限循环或大小问题。惰性求值的相反是及早求值，这是一个大多少编程语言所拥有的普通计算方式。 λ演算是一套用于研究函数定义、函数应用和递归的形式系统。这种演算可以用来清晰地定义什么是一个可计算函数。Lambda演算可以被称为最小的通用程序设计语言，它包括一条变换规则（变量替换）和一条函数定义方式，Lambda演算置通用在于，任何一个可计算函数都能用这种形式来表达和求值。因此，它是等价于图灵机的。在lambda表达式的集合定义一个等价关系（== 标注），“两个表达式其实表示的是同一个函数”这样的直觉性判断即由此表述，这种等级关系是通过所谓的“alpha-变换规则”和”beta-归约规则”。 In Ramda, a curried function can be called with only a subset of its arguments, and it will return a new function that accepts the remaining arguments. If you call a curried function with all of its arguments, it will call just call the function. You can think of a curried function as the best of both worlds: you can call it normally with all of its arguments and it will just work. Or you can call it with a subset of its arguments, and it will act as if you’d used partial. Note that this flexibility introduces a small performance hit, because curry needs to figure out how the function was called and then determine what to do. In general, I only curry functions when I find I need to use partial in more than one place. 123456const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; &#123; const selected = filter(publishedInYear(year), books) return map(book =&gt; book.title, selected)&#125; Argument OrderNotice that to make curry work for us, we had to reverse the argument order. This is extremely common with functional programming, so almost every Ramda function is written so that the data to be operated on comes last. Arguments In The Wrong order### Filp The first option is flip. flip takes a function of 2 or more arguments and returns a new function that takes the same arguments, but switches the order of the first two arguments. It is mostly used with two argument functions, but is more general than that. 1234567const publishedInYear = curry((book, year) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; &#123; const selected = filter(flip(publishedInYear)(year), books) return map(book =&gt; book.title, selected)&#125; In most cases, I’d prefer to use the more convenient argument order, but if you need to use a function you don’t control, flip is a helpful option. PlaceholderThe more general option is the “placeholder” argument (__). What if we have a curried function of three arguments, and we want to supply the first and last arguments, leaving the middle one for later? We can use the placeholder for the middle argument: 12345const threeArgs = curry((a,b,c) =&gt; &#123; /* ... */&#125;)const middleArgumentLater = threeArgs('value for a', __, 'value fro c')const middleAargumentOnly = threeArgs(__, 'value for b', __) 123456const publishedInYear = curry ((book, year) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; &#123; const selected = filter(publishedInYear(__, year), books) return map(book =&gt; book.title, selected)&#125; Note that only works for curried functions, while partial, partialRight, and flip all work on any function. If you need to use with a normal function, you can always wrap it with a call to curry first. 12345678const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = curry((year, books) =&gt; pipe( filter(publishedInYear(year)), map(book =&gt; book.title) )(books)) Cite From « Thinking in Ramda: Partial Application »","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://jiaxf.github.io/tags/functional/"},{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"ramda","slug":"ramda","permalink":"http://jiaxf.github.io/tags/ramda/"}]},{"title":"函数式编程入门","slug":"FP","date":"2018-04-19T03:48:54.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/19/FP/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/FP/","excerpt":"Function Program几个原则 DRY（不要重复自己，don’t repeat yourself） 高内聚低耦合（loose coupling high cohesion） YAGNI （你不会用到它的，ya ain’t gonna need it） 最小意外原则（Principle of least surprise） 单一责任（single responsibility） 纯函数，尽量减少副作用 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。","text":"Function Program几个原则 DRY（不要重复自己，don’t repeat yourself） 高内聚低耦合（loose coupling high cohesion） YAGNI （你不会用到它的，ya ain’t gonna need it） 最小意外原则（Principle of least surprise） 单一责任（single responsibility） 纯函数，尽量减少副作用 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。 几个数学定律应用 1234567891011// 结合律（assosiative）add(add(x, y), z) == add(x, add(y, z));// 交换律（commutative）add(x, y) == add(y, x);// 同一律（identity）add(x, 0) == x;// 分配律（distributive）multiply(x, add(y,z)) == add(multiply(x, y), multiply(x, z)); 函数柯里化curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 1234567891011121314151617var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;);var replace = curry(function(what, replacement, str) &#123; return str.replace(what, replacement);&#125;);var filter = curry(function(f, ary) &#123; return ary.filter(f);&#125;);var map = curry(function(f, ary) &#123; return ary.map(f);&#125;); 1234567891011121314151617181920212223242526272829303132match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ]var hasSpaces = match(/\\s+/g);// function(x) &#123; return x.match(/\\s+/g) &#125;hasSpaces(\"hello world\");// [ ' ' ]hasSpaces(\"spaceless\");// nullfilter(hasSpaces, [\"tori_spelling\", \"tori amos\"]);// [\"tori amos\"]var findSpaces = filter(hasSpaces);// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\\s+/g) &#125;) &#125;findSpaces([\"tori_spelling\", \"tori amos\"]);// [\"tori amos\"]var noVowels = replace(/[aeiou]/ig);// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;var censored = noVowels(\"*\");// function(x) &#123; return x.replace(/[aeiou]/ig, \"*\") &#125;censored(\"Chocolate Rain\");// 'Ch*c*l*t* R**n' “预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 高阶函数 高阶函数（higher order function）（高阶函数：参数或返回值为函数的函数）。 函数组合组合（compose，以下将称之为组合）： 12345var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。在 compose 的定义中，g 将先于 f 执行，因此就创建了一个从右到左的数据流。 组合将两个函数结合产生一个新函数。组合用法如下： 123456var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var exclaim = function(x) &#123; return x + '!'; &#125;;var shout = compose(exclaim, toUpperCase);shout(\"send in the clowns\");//=&gt; \"SEND IN THE CLOWNS!\" 123456var head = function(x) &#123; return x[0]; &#125;;var reverse = reduce(function(acc, x)&#123; return [x].concat(acc); &#125;, []);var last = compose(head, reverse);last(['jumpkick', 'roundhouse', 'uppercut']);//=&gt; 'uppercut' 123// 结合律（associativity）var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);// true 符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。所以，如果我们想把字符串变为大写，可以这么写： 1234compose(toUpperCase, compose(head, reverse));// 或者compose(compose(toUpperCase, head), reverse); 因为如何为 compose 的调用分组不重要，所以结果都是一样的。 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。让我们来重构重构前面的例子： 123456789101112var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);// 或var last = compose(head, reverse);var loudLastUpper = compose(exclaim, toUpperCase, last);// 或var last = compose(head, reverse);var angry = compose(exclaim, toUpperCase);var loudLastUpper = compose(angry, last);// 更多变种... pointfreepointfree 模式指的是，永远不必说出你的数据。函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。 1234567// 非 pointfree，因为提到了数据：wordvar snakeCase = function (word) &#123; return word.toLowerCase().replace(/\\s+/ig, '_');&#125;;// pointfreevar snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase); 12345678910// 非 pointfree，因为提到了数据：namevar initials = function (name) &#123; return name.split(' ').map(compose(toUpperCase, head)).join('. ');&#125;;// pointfreevar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));initials(\"hunter stockton thompson\");// 'H. S. T' pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，while 循环是不能组合的。不过你也要警惕，pointfree 就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 pointfree 的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。 组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。 123456789101112// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。var latin = compose(map, angry, reverse);latin([\"frog\", \"eyes\"]);// error// 正确做法：每个函数都接受一个实际参数。var latin = compose(map(angry), reverse);latin([\"frog\", \"eyes\"]);// [\"EYES!\", \"FROG!\"]) 如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的 trace 函数来追踪代码的执行情况。 123456789var trace = curry(function(tag, x)&#123; console.log(tag, x); return x;&#125;);var dasherize = compose(join('-'), toLower, split(' '), replace(/\\s&#123;2,&#125;/ig, ' '));dasherize('The world is a vampire');// TypeError: Cannot read property 'apply' of undefined 这里报错了，来 trace 下： 12var dasherize = compose(join('-'), toLower, trace(\"after split\"), split(' '), replace(/\\s&#123;2,&#125;/ig, ' '));// after split [ 'The', 'world', 'is', 'a', 'vampire' ] 啊！toLower 的参数是一个数组，所以需要先用 map 调用一下它。 12345var dasherize = compose(join('-'), map(toLower), split(' '), replace(/\\s&#123;2,&#125;/ig, ' '));dasherize('The world is a vampire');// 'the-world-is-a-vampire' trace 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。 However, it does offer a different style of coding, a style that’s taken for granted in purely functional programming languages: Ramda makes it simple for you to build complex logic through functional composition. Note that any library with a compose function will allow you do functional composition; the real point here is: “makes it simple”. 异步任务回调（callback）是通往地狱的狭窄的螺旋阶梯。使用 Quildreen Motta 的 Folktale 里的 Data.Task 1234567891011121314151617181920212223242526272829303132333435// Node readfile example://=======================var fs = require('fs');// readFile :: String -&gt; Task(Error, JSON)var readFile = function(filename) &#123; return new Task(function(reject, result) &#123; fs.readFile(filename, 'utf-8', function(err, data) &#123; err ? reject(err) : result(data); &#125;); &#125;);&#125;;readFile(\"metamorphosis\").map(split('\\n')).map(head);// Task(\"One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that// in bed he had been changed into a monstrous verminous bug.\")// jQuery getJSON example://========================// getJSON :: String -&gt; &#123;&#125; -&gt; Task(Error, JSON)var getJSON = curry(function(url, params) &#123; return new Task(function(reject, result) &#123; $.getJSON(url, params, result).fail(reject); &#125;);&#125;);getJSON('/video', &#123;id: 10&#125;).map(_.prop('title'));// Task(\"Family Matters ep 15\")// 传入普通的实际值也没问题Task.of(3).map(function(three)&#123; return three + 1 &#125;);// Task(4) 例子中的 reject 和 result 函数分别是失败和成功的回调。正如你看到的，我们只是简单地调用 Task 的 map 函数，就能操作将来的值，好像这个值就在那儿似的。到现在 map 对你来说应该不稀奇了。 如果熟悉 promise 的话，你该能认出来 map 就是 then，Task 就是一个 promise。如果不熟悉你也不必气馁，反正我们也不会用它，因为它并不纯；但刚才的类比还是成立的。 与 IO 类似，Task 在我们给它绿灯之前是不会运行的。事实上，正因为它要等我们的命令，IO 实际就被纳入到了 Task 名下，代表所有的异步操作——readFile 和 getJSON 并不需要一个额外的 IO 容器来变纯。更重要的是，当我们调用它的 map 的时候，Task 工作的方式与 IO 几无差别：都是把对未来的操作的指示放在一个时间胶囊里，就像家务列表（chore chart）那样——真是一种精密的拖延术。 一点理论前面提到，functor 的概念来自于范畴学，并满足一些定律。我们先来探索这些实用的定律。 12345// identitymap(id) === id;// compositioncompose(map(f), map(g)) === map(compose(f, g)); 总结我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。 chain 函数chain 可以轻松地嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 序列（sequence） 和 变量赋值（variable assignment）。 1234567891011121314151617181920212223242526272829// getJSON :: Url -&gt; Params -&gt; Task JSON// querySelector :: Selector -&gt; IO DOMgetJSON('/authenticate', &#123;username: 'stale', password: 'crackers'&#125;) .chain(function(user) &#123; return getJSON('/friends', &#123;user_id: user.id&#125;);&#125;);// Task([&#123;name: 'Seimith', id: 14&#125;, &#123;name: 'Ric', id: 39&#125;]);querySelector(\"input.username\").chain(function(uname) &#123; return querySelector(\"input.email\").chain(function(email) &#123; return IO.of( \"Welcome \" + uname.value + \" \" + \"prepare for spam at \" + email.value ); &#125;);&#125;);// IO(\"Welcome Olivia prepare for spam at olivia@tremorcontrol.net\");Maybe.of(3).chain(function(three) &#123; return Maybe.of(2).map(add(three));&#125;);// Maybe(5);Maybe.of(null).chain(safeProp('address')).chain(safeProp('street'));// Maybe(null); 12345querySelector(\"input.username\").chain(function(uname) &#123; return querySelector(\"input.email\").map(function(email) &#123; return \"Welcome\" + uname.value + \" prepare for spam at \" + email.value; &#125;);&#125;); 返回的如果是”普通值”就用map，如果是functor就用chain。 等式推导（equational reasoning）可靠特性(reliable properties)1234567891011121314// upload :: String -&gt; (String -&gt; a) -&gt; Voidvar upload = function(filename, callback) &#123; if(!filename) &#123; throw \"You need a filename!\"; &#125; else &#123; readFile(filename, function(err, contents) &#123; if(err) throw err; httpPost(contents, function(err, json) &#123; if(err) throw err; callback(json); &#125;); &#125;); &#125;&#125; 123456函数式编程// readFile :: Filename -&gt; Either String （Future Error String）// httpPost :: String -&gt; Futrue Error JSON// upload :: String -&gt; Either String (Futrue Error JSON)var upload = compose(map(chain(httpPost('/uploads'))), readFile); 函数式编程理论12// 结合律compose(join, map(join)) == compose(join, join) 这个定律表明了monad的嵌套本质， join map compose curry 12// 同一律compose(join, of) == compose(join, map(of)) == id 对任意的monad `M` `of` 和`join`相当与`id`，也可以使用`map(of)`由内而外实现相同效果。 这个定律叫“三角同一律”（triangle identity）。 123456789101112var mcompose = function(f, g) &#123; return compose(chain(f), chain(g));&#125;// 左同一律mcompose(M, f) == f// 右同一律mcompose(f, M) == f// 结合律mcompose(mcompose(f, g), h) == mcompose(f, mcompose(g, h)) monad 来自于一个叫 “Kleisli 范畴”的范畴，这个范畴里边所有的对象都是 monad，所有的态射都是联结函数（chained funtions）。 总结monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。当一个值被困在几层相同类型的容器中时，monad 能够拯救它。借助 “pointed” 这个可靠的帮手，monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://jiaxf.github.io/tags/函数式编程/"}]},{"title":"2018-04-19-项目基础架构","slug":"2018-04-19-项目基础架构","date":"2018-04-19T03:32:54.000Z","updated":"2018-04-19T07:10:24.000Z","comments":true,"path":"2018/04/19/2018-04-19-项目基础架构/","link":"","permalink":"http://jiaxf.github.io/2018/04/19/2018-04-19-项目基础架构/","excerpt":"","text":"项目基础架构为什么要建设基础架构？ 夯实基础，事半功倍 提高系统可用性 隔离业务代码与框架、平台 降低技术债，提高管理效率 如何实施推进？ 顺势而为，拨乱为治 自底向上，由点及面 抓住痛点，有备无患 亡羊补牢，犹未为晚","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"}]},{"title":"2018-04-17-spring_cloud简介","slug":"2018-04-17-spring-cloud简介","date":"2018-04-17T07:14:10.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/17/2018-04-17-spring-cloud简介/","link":"","permalink":"http://jiaxf.github.io/2018/04/17/2018-04-17-spring-cloud简介/","excerpt":"","text":"Spring Cloud 简介Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，springcloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，springcloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。 主要的小弟有：Spring Cloud Config、Spring Cloud Netflix（Eureka、Hystrix、Zuul、Archaius…）、Spring Cloud Bus、Spring Cloud for Cloud Foundry、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Sleuth、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud Zookeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI。 核心成员Spring Cloud Netflix这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了 Netflix Eureka服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。 Netflix Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。 Netflix ZuulZuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。 Netflix Archaius配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。 Spring Cloud Config俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。就是以后大家武器、枪火什么的东西都集中放到一起，别随便自己带，方便以后统一管理、升级装备。 Spring Cloud Bus事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。 Spring Cloud for Cloud FoundryCloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了Cloud Foundry的大腿。 Spring Cloud ClusterSpring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。 Spring Cloud ConsulConsul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 其它小弟### Spring Cloud Security 基于spring security的安全工具包，为你的应用程序添加安全控制。这个小弟很牛鼻专门负责整个帮派的安全问题，设置不同的门派访问特定的资源，不能把秘籍葵花宝典泄漏了。 Spring Cloud Sleuth日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。 Spring Cloud Data FlowData flow 是一个用于开发和执行大范围数据处理其模式包括ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow是一个原生云可编配的服务。使用Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入/导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 Spring Boot的stream 和 task/batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。 Spring Cloud StreamSpring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于Spring Boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的，这就是Spring Cloud stream要干的事了 Spring Cloud TaskSpring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。 Spring Cloud ZookeeperZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。 Spring Cloud ConnectorsSpring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。 便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。 Spring Cloud StartersSpring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。 Spring Cloud CLI基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 和Spring Boot 是什么关系Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现,可以不基于Spring Boot吗？不可以。 Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 spring -&gt; spring booot &gt; Spring Cloud 这样的关系。 Spring Cloud的优势微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？ 产出于spring大家族，spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。比如dubbo现在就差不多死了 有Spring Boot 这个独立干将可以省很多事，大大小小的活Spring Boot都搞的挺不错。 作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。 Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案 轻轻松松几行代码就完成了熔断、均衡负责、服务中心的各种平台功能 Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。","categories":[],"tags":[]},{"title":"2018/04/17/spring-boot入门.md","slug":"2018-04-17-spring-boot入门","date":"2018-04-17T06:19:50.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/17/2018-04-17-spring-boot入门/","link":"","permalink":"http://jiaxf.github.io/2018/04/17/2018-04-17-spring-boot入门/","excerpt":"","text":"SpringBoot入门什么是Spring Boot？SpringBoot简化了基于Spring的应用开发，通过少量代码就能创建一个独立的、产品级别的Spring应用。SpringBoot为spring平台及第三方库提供开箱即用的设置，该框架使用特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。SpringBoot的核心思想是约定大于配置，一切自动完成。采用SpringBoot可以大大的简化开发模式。 使用spring boot的好处简单、快速、方便。 平时搭建一个spring web 项目的时候需要怎么做呢？ 1) 配置web.xml,加载spring和spring mvc 2) 配置数据库连接、配置spring事务 3) 配置加载配置文件的读取，开启注解 4) 配置日志文件 … 配置完成部署tomcat调试 … 使用spring boot快速搭建，构建微服务。 快速入门maven构建项目 访问http://start.spring.io 选择构建工具Maven Project、Spring Boot版本及一些工程信息，点击“Switch to the full version”。 点击Generate Project下周项目压缩包 解压后，使用eclipse， Import-&gt;Existing Maven Projects-&gt; Next -&gt; 选择解压后的文件夹-&gt; Finsh, OK done! 项目结构 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到根目录下面,主要用于做一些框架配置 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改。 最后，启动Application main方法，至此一个java项目搭建好了！ 引入ｗｅｂ模块 1、pom.xml中添加支持web的模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter ：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test ：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容：1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String index() &#123; return \"Hello World\"; &#125;&#125; @RestController 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello，就可以看到效果了，有木有很简单！ 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(\"/hello\").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"Hello World\"))); &#125;&#125; 开发环境调试springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：12345678910111213141516171819 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"spring","slug":"spring","permalink":"http://jiaxf.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jiaxf.github.io/tags/java/"}]},{"title":"2018/04/17/spring-boot入门.md","slug":"2018-04-17-spring-boot入门0","date":"2018-04-17T06:19:50.000Z","updated":"2018-05-02T00:53:36.000Z","comments":true,"path":"2018/04/17/2018-04-17-spring-boot入门0/","link":"","permalink":"http://jiaxf.github.io/2018/04/17/2018-04-17-spring-boot入门0/","excerpt":"","text":"SpringBoot入门什么是Spring Boot？SpringBoot简化了基于Spring的应用开发，通过少量代码就能创建一个独立的、产品级别的Spring应用。SpringBoot为spring平台及第三方库提供开箱即用的设置，该框架使用特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。SpringBoot的核心思想是约定大于配置，一切自动完成。采用SpringBoot可以大大的简化开发模式。 使用spring boot的好处简单、快速、方便。 平时搭建一个spring web 项目的时候需要怎么做呢？ 1) 配置web.xml,加载spring和spring mvc 2) 配置数据库连接、配置spring事务 3) 配置加载配置文件的读取，开启注解 4) 配置日志文件 … 配置完成部署tomcat调试 … 使用spring boot快速搭建，构建微服务。 快速入门maven构建项目 访问http://start.spring.io 选择构建工具Maven Project、Spring Boot版本及一些工程信息，点击“Switch to the full version”。 点击Generate Project下周项目压缩包 解压后，使用eclipse， Import-&gt;Existing Maven Projects-&gt; Next -&gt; 选择解压后的文件夹-&gt; Finsh, OK done! 项目结构 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到根目录下面,主要用于做一些框架配置 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改。 最后，启动Application main方法，至此一个java项目搭建好了！ 引入ｗｅｂ模块 1、pom.xml中添加支持web的模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter ：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test ：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容：1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String index() &#123; return \"Hello World\"; &#125;&#125; @RestController 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello，就可以看到效果了，有木有很简单！ 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(\"/hello\").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"Hello World\"))); &#125;&#125; 开发环境调试springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：12345678910111213141516171819 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"spring","slug":"spring","permalink":"http://jiaxf.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jiaxf.github.io/tags/java/"}]},{"title":"2018-04-16-github上备份Hexo博客.md","slug":"2018-04-16-github上备份Hexo博客","date":"2018-04-16T01:06:04.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/16/2018-04-16-github上备份Hexo博客/","link":"","permalink":"http://jiaxf.github.io/2018/04/16/2018-04-16-github上备份Hexo博客/","excerpt":"","text":"Github上备份Hexo博客前言配置好Git和Github环境后，Hexo博客的markdown文件备份。Git相关操作请参考廖雪峰的Git教程。 备份博客假设本地Hexo博客已经初始化，如果没有配置好Hexo博客详见「Ubuntu16.04下从零起步搭建配置github.io博客————Hexo」。 创建新分支git可以很方便和低代价的创建新分支，可以利用git的新分支来备份博客。 本地Git建立新分支 $ git checkout -b BRANCHNAME BRANCHNAME是自定义的新分支的名字，建议起为hexo。 建立.gitignore建立.gitignore 文件将不需要备份的文件屏蔽。参考.gitignore文件如下： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/*.deploy*/ Github上备份假设当前在hexo博客的根目录下。 123$ git add .$ git commit -m \"Backup\"$ git push origin hexo github上有两个分支（master和 hexo） 个人备份习惯个人而言习惯先备份文件再生产博客。执行1234$ git add .$ git commit -m \"Backup\"$ git push origin hexo$ hexo g -d 恢复博客克隆项目到本地输入命令克隆博客必须文件（hexo分支） $ git clone https://github.com/jiaxf/jiaxf.github.io 恢复博客在克隆的文件夹下输入如下命令恢复博客： 123$ npm install hexo$ npm install$ npm install hexo-deployer-git 注：不再需要执行hexo init命令。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"git","slug":"git","permalink":"http://jiaxf.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://jiaxf.github.io/tags/hexo/"}]},{"title":"2018-04-13-技术随笔.md","slug":"2018-04-13-python-md-1","date":"2018-04-13T03:31:04.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2018/04/13/2018-04-13-python-md-1/","link":"","permalink":"http://jiaxf.github.io/2018/04/13/2018-04-13-python-md-1/","excerpt":"","text":"Mac下零配置serverPowPow is a zero-config Rack Server for Mac。 Installcurl get.pow.cx | sh SetupSymlink the folder into ~/.pow $ cd ~/.pow $ ln -s /path/to/myapp Your website will be up and running at http://myapp.dev. The URL is based on the name of the symlink.","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/tags/技术/"},{"name":"mac","slug":"mac","permalink":"http://jiaxf.github.io/tags/mac/"}]},{"title":"JavaScriptEvent","slug":"javascriptEvent","date":"2016-12-01T02:35:00.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2016/12/01/javascriptEvent/","link":"","permalink":"http://jiaxf.github.io/2016/12/01/javascriptEvent/","excerpt":"JavaScript事件1. 相关术语 事件类型（event type）是一个用来说明发生什么类型事件的字符串。 例如，“mousemove”表示用户移动鼠标，“keydown”表示键盘上某个键被按下等等。 事件目标（event target）是发生的事件与之相关的对象。当讲事件时，我必须同时指明类型和目标。 比如：window上的load事件或button元素的click事件。 在客户端JavaScript应用程序中，Window、Document和Element对象是最常见的事件目标。 事件处理程序（event handler）或事件监听程序（event listener）是处理或响应事件的函数。 事件对象（event object）是与特定事件相关且包含有关该事件详细信息的对象。 事件对象作为参数传递给事件处理程序函数（不包括IE8及之前版本，在这些浏览器中有时仅能通过全局变量event才能得到）。 所有的事件对象都用来指定事件类型的type属性和指定事件目标的target属性。（在IE8及之前的版本中用srcElement而非target） 事件传播（event propagation）是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上传播或“冒泡“（bubble）。 事件捕获（event capturing）：在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获它。","text":"JavaScript事件1. 相关术语 事件类型（event type）是一个用来说明发生什么类型事件的字符串。 例如，“mousemove”表示用户移动鼠标，“keydown”表示键盘上某个键被按下等等。 事件目标（event target）是发生的事件与之相关的对象。当讲事件时，我必须同时指明类型和目标。 比如：window上的load事件或button元素的click事件。 在客户端JavaScript应用程序中，Window、Document和Element对象是最常见的事件目标。 事件处理程序（event handler）或事件监听程序（event listener）是处理或响应事件的函数。 事件对象（event object）是与特定事件相关且包含有关该事件详细信息的对象。 事件对象作为参数传递给事件处理程序函数（不包括IE8及之前版本，在这些浏览器中有时仅能通过全局变量event才能得到）。 所有的事件对象都用来指定事件类型的type属性和指定事件目标的target属性。（在IE8及之前的版本中用srcElement而非target） 事件传播（event propagation）是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上传播或“冒泡“（bubble）。 事件捕获（event capturing）：在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获它。 2.Event事件2.1 注册事件处理程序 给事件目标对象或文档元素设置属性，onclick、onchange等 2.2 通过addEventListener() 1target.addEventListener(type, listener[, useCapture]); type：事件名称（事件类型），字符串，大小写不敏感。 listener：监听函数。事件发生时，会调用该监听函数。 useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。老式浏览器规定该参数必写，较新版本的浏览器允许该参数可选。为了保持兼容，建议总是写上该参数。 使用addEventListener(）方法时，事件类型不应包括前缀“on”. 去除 removeEventListener（） 1addEventListener('click', listener, false); 2.3 事件处理程序的返回值 设置对象属性或HTML属性注册事件处理程序的返回值false告诉浏览器不要执行事件相关的默认操作。比如，表单提交按钮的onclick事件处理程序能返回false阻止浏览器提交表单。 123v.onclick = function()&#123; return false;&#125; 2.4 事件调用顺序 通过设置对象属性或HTML属性注册的处理程序一直优先调用 使用addEventListener() 注册的处理程序按照注册顺序调用 使用attachEvent() 注册的处理程序可能按照任何顺序调用，代码不应该依赖于调用顺序。 2.5 事件传播 在调用在目标元素上注册的事件处理函数，大部分事件会”冒泡”到DOM树根。发生再文档元素上的大部分事件都会冒泡，有些例外，比如 focus、blur和scroll事件。文档元素上的load事件会冒泡，但会在Document对象上停止冒泡而不会传播到Window对象。只有整个文档 都加载完毕时才会触发window对象的load事件。 三个阶段： 捕获阶段（capture phrase）： 从window对象传导到目标对象。（window —-&gt;document —&gt; … —&gt; 目标对象） 目标阶段（target phrase）： 目标对象本身的事件处理程序调用 冒泡阶段（bubblling phrase）：从目标对象传导会window对象 （目标对象—&gt; 父元素—&gt; … —&gt; document –&gt;window） 2.6 事件代理（事件委托） 基于事件会在冒泡阶段向上传播到父节点，可以将子节点的监听事件定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方叫事件的代理（delegation）。 使用事件代理，以后插入的新节点仍然可可以监听到事件 2.7 事件取消 用属性注册的事件处理程序返回值能用于取消事件的浏览器默认操作。在支持addEventListener()的浏览器中，能通过调用事件对象的 preventDefault（）方法取消事件的默认操作。 在IE9之前的IE中，可以通过设置事件对象的returnValue属性为false来取消。 12345678910function cancelHandler(event)&#123; var event = event || window.event; if(event.preventDefault)&#123; // 标准 event.preventDefault; &#125; if(event.returnValue)&#123; // IE event.returnValue = false; &#125; return false; //用于处理使用对象属性注册的处理程序&#125; 取消事件传播 在支持addEventListener()的浏览器中，可以调用事件对象的一个stopPropagation()方法以阻止事件的传播。 Event对象上还有个方法stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用。 123e.stopPropagation();// IEe.cancelBubble = true; 3. 文档事件 (1) beforeunload事件、unload事件、load事件、error事件、pageshow事件、pagehide事件 (2) DOMContentLoader事件、readystatechange事件 DOMContentLoader事件再文档加载解析完毕，图片和异步（async）脚本依旧在加载，单文档已准备就绪。发生再load事件之前。 readstatechange事件：document.readystatechange属性会随文档加载过程而变，每次状态改变，Document对象上的readystatechange事件都会触发。 12345document.onreadystate = function()&#123; if(doucment.readyState == 'complete')&#123; &#125;&#125; (3) scroll事件、resize事件 (4) hashchange事件、popstate事件 (5) cut事件、copy事件、 paste事件 文本操作事件 - cut事件：将选中的内容从文档中移除，加入剪贴板后触发 - copy事件： 在选中的内容加入剪贴板后触发 - paste事件： 在剪贴板内容被粘贴到文档后触发 三个事件都有一个clipboardData只读属性，该属性存放剪贴的数据，是一个DataTransfer对象。 （6）焦点事件 发生在Element节点和document对象上。 focus事件、blur事件、focusin事件、focusout事件 4. 鼠标事件 （1） click事件 在Element节点、document节点、window对象上，单击鼠标时触发。 （2）contextmenu 在一个节点上点击鼠标右键时触发，或者按下“上下文菜单”键时触发。 (3) dblclick (4) mousedown、mouseup、mousemove、mouseover、mouseenter、mouseout、mouseleave 除了mouseenter和mouseleave外的所有鼠标事件都能冒泡。 5. 鼠标滚轮事件 浏览器支持mousewheel事件，但Firefox使用”DOMMouseScroll”事件。 123456789101112131415161718window.onmousewheel = document.onmousewheel = scrollWheel;function scrollWheel(e)&#123; e = e || window.event; if(e.wheelDelta)&#123; // 判断浏览器IE，谷歌滑轮事件 if(e.wheelDelta &gt; 0)&#123; // 滑轮向上滚动时 &#125;else if(e.wheelDelta &lt; 0)&#123; // 当滑轮向下滚动时 &#125;； &#125;else if(e.dedail)&#123; // Firefox滑轮事件 if(e.detail &lt; 0)&#123; // 当滑轮向上滚动时 &#125;else if(e.detail &gt; 0)&#123; // 当滑轮向下滚动时 &#125; &#125;&#125; ## 6. 键盘事件 keydown、keypress、keyup 7. 表单事件 （1）input、propertychange （用在&lt;input&gt;、&lt;textarea&gt;， 当contenteditable属性设置为true时值变化触发） （2）change （&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;值变化时触发） - 激活单选框（radio）或复选框（checkbox）时触发。 - 用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。 - 当文本框或textarea元素的值发生改变，并且丧失焦点时触发。 （3）select （当&lt;input&gt;和&lt;textarea&gt; 中选中文本时触发select事件） （4）reset、submit（表单对象事件） - reset事件：当表单重置（所有表单成员的值变回默认值）时触发。 - submit事件：当表单数据向服务器提交时触发。 8. 触控事件 触控事件提供了响应用户对触摸屏或触摸板上的操作能力。 接口： TouchEvent：代表当触摸行为在平面上发生变化时发生的事件（touchstart、touchend、touchmove、touchcancel、touchenter、touchleave） Touch：代表用户与触摸屏幕间的一个接触点 TouchList：代表一系列的Touch；一般在用户多个手指同时解除屏幕时使用其他： gesturestart、gestureendscale、rotation 9. 进度事件 进度事件用例描述一个事件进展的过程。 abort事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。 error事件：由于错误导致资源无法加载时触发。 load事件：进度成功结束时触发。 loadstart事件：进度开始时触发。 loadend事件：进度停止时触发，发生顺序排在error事件\\abort事件\\load事件后面。 progress事件：当操作处于进度之中，由传输的数据块不断触发。 timeout事件：进度超过限时触发。 10. 拖放事件 拖放（Drag-and-Drop，DnD）是在“拖放源drag source”和”拖放目标drop target”之间传输数据的用户界面。 （1）事件 dragstart：当一个元素开始被拖拽的时候触发。用户拖拽的元素需要附加dragstart事件。在这个事件中，监听器将设置与这次拖拽相关的信息，例如拖动的数据和图像。 dragenter：当拖拽中的鼠标第一次进入一个元素的时候触发。这个事件的监听器需要指明是否允许在这个区域释放鼠标。如果没有设置监听器，或者监听器没有进行操作，则默认不允许释放。当你想要通过类似高亮或插入标记等方式来告知用户此处可以释放，你将需要监听这个事件。 dragover：当拖拽中的鼠标移动经过一个元素的时候触发。大多数时候，监听过程发生的操作与dragenter事件是一样的。 dragleave：当拖拽中的鼠标离开元素时触发。监听器需要将作为可释放反馈的高亮或插入标记去除。 drag：这个事件在拖拽源触发。即在拖拽操作中触发dragstart事件的元素。 drop：这个事件在拖拽操作结束释放时于释放元素上触发。一个监听器用来响应接收被拖拽的数据并插入到释放之地。这个事件只有在需要时才触发。当用户取消了拖拽操作时将不触发，例如按下了Escape（ESC）按键，或鼠标在非可释放目标上释放了按键。 dragend：拖拽源在拖拽操作结束将得到dragend事件对象，不管操作成功与否。 （2）DataTransfer对象 dataTransfer属性用例保存需要传递的数据，返回一个DataTransfer对象。 setData() 用来设置事件所带有的指定类型的数据。两个参数：一个是数据类型，第二个时具体数据。 11. 自定义事件123456// 新建事件实例var event = new Event('play');// 添加监听函数element.addEventListener('play', function(e)&#123;&#125;, false);// 触发事件element.dispatchEvent(event); 可以使用CustomEvent构造函数生成自定义的事件对象。 1234567891011121314151617181920var event = new CustomEvent('play', &#123;detail: 'play'&#125;);// 添加监听函数element.addEventListener('play', handler, false);// 触发事件element.dispatchEvent(event);function handler(e)&#123; var data = e.detail;&#125;// IE 不支持上面写法// 新建Event实例var event = document.createEvent('Event');// 事件初始化event.initEvent('play', true, true);// 加上监听函数document.addEventListener('play', handler, fasle);// 触发事件document.dispatchEvent(event); type：事件名称，格式为字符串。 bubbles：事件是否应该冒泡，格式为布尔值。可以使用event.bubbles属性读取它的值。 cancelable：事件是否能被取消，格式为布尔值。可以使用event.cancelable属性读取它的值。 option：为事件对象指定额外的属性。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"event","slug":"event","permalink":"http://jiaxf.github.io/tags/event/"}]},{"title":"React入门","slug":"reactStudy","date":"2016-11-30T05:51:02.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2016/11/30/reactStudy/","link":"","permalink":"http://jiaxf.github.io/2016/11/30/reactStudy/","excerpt":"React入门运行React需要的3个库： react.js、react-dom.js、Browser.js react.js时React的核心库 react-dom.js是提供与DOM相关的功能 Browser.js的作用时将JSX语法转换为JavaScript语法，这一步较耗时间，世界上线时可以放到服务器完成， $ babel src --out-dir build","text":"React入门运行React需要的3个库： react.js、react-dom.js、Browser.js react.js时React的核心库 react-dom.js是提供与DOM相关的功能 Browser.js的作用时将JSX语法转换为JavaScript语法，这一步较耗时间，世界上线时可以放到服务器完成， $ babel src --out-dir build HTML模板使用React的网页源码，模板如下： 123456789101112131415&lt;DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"./react.js\"&gt;&lt;/script&gt; &lt;script src=\"./react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"./browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ReactDOM.render()ReactDOM.render 是React的基本方法，用于将模板转为HTML语言，并插入指定的DOM节点。 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); JSX语法JSX语法允许HTML与JavaScript混写，遇到HTML标签（以〈开头），用HTML规则解析； 遇到代码块（以{开头）,用Javascript规则解析。 React组件React允许将代码封装成组件(component)，然后像插入普通HTML标签一样，在网页中插入这个组件。React.createClass方法用于生成一个组件类。 组件的名字必须首字母大写 组件类必须有自己的render方法，用于输出组件 组件的用户与原生的HTML标签一样，可以加入属性，组件的属性可以在组件类的this.props对象上获取 注：添加组件的属性，class属性需要写成className，for属性需要写成htmlFor，因为class和for是JavaScript的保留字 eg: 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=\"John\" /&gt;, document.getElementById('example')); this.props.childrenthis.props对象的属性与组件的属性一一对应，this.props.children属性表示组件的所有子节点 this.props.children的值有三种可能： 如果当前组件没有子节点，就是undefined; 如果有一个子节点，数据类型是object; 如果有多个子节点，数据类型就是array; React提供一个工具方法React.Children来处理this.props.children，可以利用React.Children.map来遍历子节点。 虚拟 DOM （virtual DOM）组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 eg： 123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=\"myTextInput\" /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 组件中的属性类型验证组件类的PropTypes属性，可以用来验证组件实例的属性是否符合要求。 eg: 123456789101112131415161718var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);var data = 123;ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt;, document.body);// title属性不能通过验证，控制台会显示错误// Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`. 组件的状态组件可以看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI。 eg:123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); 组件的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 React组件的生命周期组件的生命周期分为三个状态： Mounting：已插入真实DOM Updating：正在被重新渲染 Unmounting：已移出真实DOM React为每个状态都提供了俩种处理函数，will函数在进入状态之前调用，did函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() React还提供俩种特殊状态的处理函数 componentWillReceiveProps(object nextProps): 已加载组件收到新的参数时调用 shouldComponentUpdate（object nextProps, object nextState): 组件判断是否重新渲染时调用","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jiaxf.github.io/tags/react/"},{"name":"jsx","slug":"jsx","permalink":"http://jiaxf.github.io/tags/jsx/"}]},{"title":"js错误类型","slug":"javascript错误","date":"2016-11-29T05:51:02.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2016/11/29/javascript错误/","link":"","permalink":"http://jiaxf.github.io/2016/11/29/javascript错误/","excerpt":"JavaScript原生错误类型Error对象是最一遍的错误类型,在它基础上,JavaScript还定义了其他6种错误派生对象. (1) SyntaxError 解析代码时发生的错误.12345// 变量名错误var 1a;// 缺少括号console.log 'Hello'); (2) ReferenceError 引用一个不存在的变量时发生的错误.123unknowVariable// ReferenceError: unknownVariable is not defined","text":"JavaScript原生错误类型Error对象是最一遍的错误类型,在它基础上,JavaScript还定义了其他6种错误派生对象. (1) SyntaxError 解析代码时发生的错误.12345// 变量名错误var 1a;// 缺少括号console.log 'Hello'); (2) ReferenceError 引用一个不存在的变量时发生的错误.123unknowVariable// ReferenceError: unknownVariable is not defined (3) RangeError 当一个值超出有效范围时发生的错误.123456new Array(-1)// RangeError: Invalid array length(1234).toExponential(21)// RangeError: toExponential() argument must be between 0 and 20 (4) TypeError 变量或参数不是预期类型时发生的错误.比如,对字符串、布尔值、数值等原始类型的值使用new命令,就会抛出这种错误,因为new命令的参数应该是一个构造函数.123456new 123// TypeError: number is not a funcvar obj = &#123;&#125;;obj.unknownMethod()// TypeError: obj.unknownMethod is not a function (5) URIError URI相关函数的参数不正确时抛出的错误,主要涉及encodeURI()、 decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()六个函数.12decodeURI('%2')// URIError: URI malformed (6) EvalError eval函数没有正确执行时,会抛出EvalError错误.JavaScript还可以自定义错误类型.1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = \"UserError\";&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; Written By jiaxf","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaxf.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"http://jiaxf.github.io/tags/js/"}]},{"title":"php数据类型","slug":"2015-02-14-php数据类型","date":"2015-02-13T16:00:00.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2015/02/14/2015-02-14-php数据类型/","link":"","permalink":"http://jiaxf.github.io/2015/02/14/2015-02-14-php数据类型/","excerpt":"php数据类型字符串、整数、浮点数、逻辑、数组、对象、NULL。 PHP var_dump() 会返回变量的数据类型和值 PHP 字符串 字符串可以是引号内的任何文本,可以使用单引号或双引号： 学习笔记PHP整数 PHP 整数可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0） PHP浮点数 浮点数是有小数点或指数形式的数字","text":"php数据类型字符串、整数、浮点数、逻辑、数组、对象、NULL。 PHP var_dump() 会返回变量的数据类型和值 PHP 字符串 字符串可以是引号内的任何文本,可以使用单引号或双引号： 学习笔记PHP整数 PHP 整数可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0） PHP浮点数 浮点数是有小数点或指数形式的数字 PHP 逻辑 true 或 false。 PHP 数组 数组在一个变量中存储多个值。 1234&lt;?php$cars=array(\"Volvo\",\"BMW\",\"SAAB\");var_dump($cars);? array() 函数用于创建数组; 三种数组类型： 索引数组 - 带有数字索引的数组 关联数组 - 带有指定键的数组 多维数组 - 包含一个或多个数组的数组 获得数组的长度 - count() 函数count() 函数用于返回数组的长度（元素数）： 遍历索引数组遍历并输出索引数组的所有值，可以使用 for 循环 12345678&lt;?php$cars=array(\"Volvo\",\"BMW\",\"SAAB\");$arrlength=count($cars);for($x=0;$x&lt;$arrlength;$x++) &#123; echo $cars[$x]; echo \"&lt;br\";&#125;? 遍历关联数组遍历并输出关联数组的所有值，可以使用 foreach 循环 12345678&lt;?php$age=array(\"Bill\"=\"35\",\"Steve\"=\"37\",\"Peter\"=\"43\");foreach($age as $x=$x_value) &#123; echo \"Key=\" . $x . \", Value=\" . $x_value; echo \"&lt;br\";&#125;? PHP 对象 对象是存储数据和有关如何处理数据的信息的数据类型。 在 PHP 中，必须明确地声明对象。 首先必须声明对象的类，使用 class 关键词。类是包含属性和方法的结构。 然后在对象类中定义数据类型，然后在该类的实例中使用此数据类型： 123456789101112&lt;?phpclass Car&#123; var $color; function Car($color=\"green\") &#123; $this-color = $color; &#125; function what_color() &#123; return $this-color; &#125;&#125;? PHP NULL 值 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。 NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。 可以通过把值设置为 NULL，将变量清空","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://jiaxf.github.io/tags/php/"}]},{"title":"php学习笔记","slug":"2015-02-14-php学习笔记","date":"2015-02-13T16:00:00.000Z","updated":"2018-04-19T03:48:54.000Z","comments":true,"path":"2015/02/14/2015-02-14-php学习笔记/","link":"","permalink":"http://jiaxf.github.io/2015/02/14/2015-02-14-php学习笔记/","excerpt":"php学习笔记php能做什么？php能够生成动态页面内容； php能够创建、打开、读取、写入、删除并关闭服务器上的文件； php能够接收表单数据； php能够发送并取回cookie； pph能够添加、删除、修改数据库中的数据； php能够限制用户访问网站中的某些页面； php能够对数据进行加密； 为什么使用php？php运行于各种平台 php兼容所有服务器（apache\\iis） php支持多种数据库 php高效，易于学习","text":"php学习笔记php能做什么？php能够生成动态页面内容； php能够创建、打开、读取、写入、删除并关闭服务器上的文件； php能够接收表单数据； php能够发送并取回cookie； pph能够添加、删除、修改数据库中的数据； php能够限制用户访问网站中的某些页面； php能够对数据进行加密； 为什么使用php？php运行于各种平台 php兼容所有服务器（apache\\iis） php支持多种数据库 php高效，易于学习 Debian下php环境安装# apt-get install php5-common libapache2-mod-php5 php5-cli # apt-get install php5-curl php5-mysql PHP 变量规则：变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 注释：PHP 变量名称对大小写敏感！ PHP 是一门类型松散的语言,不必告知 PHP 变量的数据类型 PHP 根据它的值，自动把变量转换为正确的数据类型。 PHP变量作用域PHP 有三种不同的变量作用域： local（局部） global（全局） static（静态） Local 和 Global 作用域函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。 PHP global 关键词 global 关键词用于访问函数内的全局变量。要做到这一点，请在（函数内部）变量前面使用 global 关键词： PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。 PHP static 关键词 通常，当函数完成/执行后，会删除函数内的所有局部变量。首次声明变量时使用 static 关键词的变量不会被删除。每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。注释：该变量仍然是函数的局部变量。 PHP echo 和 print 语句echo 和 print 之间的差异： echo - 能够输出一个以上的字符串 print - 只能输出一个字符串，并始终返回 提示：echo 比 print 稍快，因为它不返回任何值。","categories":[{"name":"技术","slug":"技术","permalink":"http://jiaxf.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://jiaxf.github.io/tags/php/"}]}]}